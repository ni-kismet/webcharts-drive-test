{"version":3,"sources":["niTimeStamp.js","niAnalogWaveform.js","niComplex.js","niNumericFormatters.js","niType.js"],"names":["MAX_SAFE_INTEGER","Number","NITimestamp","value","timeInMilliSeconds","timeInSeconds","remainder","this","epochDiffInSeconds","parts","split","seconds","Math","floor","parseFloat","fractionalPart","fractions","ceil","Date","getTime","proto","prototype","toString","round","toJSON","toDate","valueOf","toAbsoluteTime","compare","timestamp","add","dt","fraction","window","NIAnalogWaveform","JSON","parse","e","t0","channelName","Y","undefined","sampleCount","length","toTimeAndValueArray","res","i","ts","push","appendArray","arr","Array","isArray","appendWaveform","waveform","slice","expectedT0","NIComplex","imag","complexNumber","parseFromString","realPart","imaginaryPart","Error","spaceRemovalRegex","middleSignRegex","testRealRegex","testImagRegex","testRealScientificNotationRegex","testImagScientificNotationRegex","checkRealInfinityRegex","checkImagInfinityRegex","transformInfinityRegex","checkOnlyI","checkNaN","fastPathComplexRegex","realPartOnlyRegex","imaginaryPartOnlyRegex","realPartSIRegex","imaginaryPartSIRegex","scientificAndSINotationRegex","scientificAndSINotationReversedRegex","getRealPart","result","test","NaN","search","getImaginaryPart","valueWithoutI","fastParseFromString","complexString","middleSignIndex","substring","thoroughParseFromString","realSubString","imagSubString","replace","exec","realPartCoefficient","imaginaryPartCoefficient","scientificToDecimal","realPartSITest","imaginaryPartSITest","isNaN","scientificValue","prefixesToPowers","Z","E","P","T","G","M","k","c","m","u","n","p","f","a","z","y","numericPart","prefix","pow","numericPartOfImaginary","complexNumb","complexNumbMagnitute","sqrt","thisMagnitute","abs","NINumericFormatters","getLog10","x","log","LOG10E","getExtension","exponent","extensionTable","index","conversion","extension","removeLastZero","numberStr","exp","indexOf","dotIndex","lastZero","lastIndexOf","toUpperCase","toSiNotation","nrOfDecimals","decimals","isFinite","mantissa","extensionData","toExponential","toFixed","toDecPrecisionNotation","nrOfDigits","partialVal","stringValue","dotPosition","eNotation","toPrecision","toDecFixedNotation","nrOfecimals","sign","number","TypeNames","Object","freeze","VOID","BOOLEAN","UINT8","UINT16","UINT32","UINT64","INT8","INT16","INT32","INT64","SINGLE","DOUBLE","COMPLEXSINGLE","COMPLEXDOUBLE","STRING","PATH","TIMESTAMP","ENUM","CLUSTER","ARRAY","ANALOGWAVEFORM","DIGITALWAVEFORM","isFloat","typeName","isSignedInteger","isUnsignedInteger","is64BitInteger","isInteger","isComplex","isNumeric","isAggregateType","validProperties","descriptor","propertyCount","keys","validatePrimitives","name","isValidArraySubtype","validateEnum","subtype","validateArray","validateType","rank","arrayFixedSize","size","reduce","prev","curr","validateCluster","fields","fieldTypes","fieldType","message","validateAnalogWaveform","type","wrapShortTypes","key","hasOwnProperty","map","unwrapShortType","encodeShortType","fieldsEqual","fields1","fields2","pv","cv","subtypesEqual","subtype1","subtype2","NIType","equals","ranksEqual","rank1","rank2","sizesEqual","sizes1","sizes2","parseDescriptor","descriptorValue","_descriptor","generateTypeCheker","typeChecker","defineProperty","typeDescriptorObject","isQuery","stringify","toShortJSON","makeArray","getName","getSubtype","_nisubtype","v","getRank","getSize","getFields","typeDescriptor","NITypes","NITypeNames"],"mappings":"CAKA,WACA,YAEA,IAAAA,GAAAC,OAAAD,kBAAA,iBAYAE,EAAA,SAAAC,GACA,GAAAC,GAAAC,EAAAC,CAGA,IAFAC,KAAAC,mBAbA,WAeA,gBAAAL,GAAA,CACA,GAAAM,GAAAN,EAAAO,MAAA,IACAH,MAAAI,QAAAC,KAAAC,MAAAC,WAAAL,EAAA,IACA,IAAAM,GAAAD,WAAAL,EAAA,GAEAM,GAAA,qBACAA,EAAA,oBAGAR,KAAAS,UAAAJ,KAAAK,KAAAF,EAAA,OAAAf,EAAA,OACAG,aAAAe,OACAd,EAAAD,EAAAgB,UACAd,EAAAO,KAAAC,MAAAT,EAAA,KACAG,KAAAI,QAAAN,EAAAE,KAAAC,mBAEAF,GAAAF,EAAA,IAAA,KAAA,IACAG,KAAAS,UAAAV,EAAA,KACA,gBAAAH,IACAE,EAAAO,KAAAC,MAAAV,GACAI,KAAAI,QAAAN,EACAE,KAAAS,UAAAb,EAAAE,GACAF,YAAAD,IAEAK,KAAAI,QAAAR,EAAAQ,QACAJ,KAAAS,UAAAb,EAAAa,YAEAT,KAAAI,QAAA,EACAJ,KAAAS,UAAA,IAIAI,EAAAlB,EAAAmB,SAEAD,GAAAE,SAAA,WACA,MAAAV,MAAAC,MAAAN,KAAAI,SAAA,IAAAC,KAAAW,MAAAhB,KAAAS,WAAAhB,EAAA,GAAA,OAGAoB,EAAAI,OAAA,WACA,MAAAjB,MAAAe,YAGAF,EAAAK,OAAA,WACA,MAAA,IAAAP,MAAA,KAAAX,KAAAI,QAAAJ,KAAAC,mBAAAD,KAAAS,aAGAI,EAAAM,QAAA,WACA,MAAAnB,MAAAI,QAAAJ,KAAAS,WAIAI,EAAAO,eAAA,WACA,MAAApB,MAAAI,QAAAJ,KAAAS,UAjEA,YADA,YAqEAI,EAAAQ,QAAA,SAAAC,GACA,MAAAtB,MAAAI,QAAAkB,EAAAlB,SACA,EACAJ,KAAAI,QAAAkB,EAAAlB,QACA,EAEAJ,KAAAS,UAAAa,EAAAb,WACA,EACAT,KAAAS,UAAAa,EAAAb,UACA,EAEA,GAKAI,EAAAU,IAAA,SAAAC,GACAxB,KAAAI,SAAAC,KAAAC,MAAAkB,EACA,IAAAC,GAAAD,EAAAnB,KAAAC,MAAAkB,EASA,OARAC,IAAAzB,KAAAS,UACAgB,GAAA,IACAA,GAAA,EACAzB,KAAAI,SAAA,GAGAJ,KAAAS,UAAAgB,EAEAzB,MAGA0B,OAAA/B,YAAAA,KCvGA,WACA,YACA,IAAAA,GAAA+B,OAAA/B,YAEAgC,EAAA,SAAA/B,GACA,GAAA,gBAAAA,GACA,IACAA,EAAAgC,KAAAC,MAAAjC,GACA,MAAAkC,GACA,KAAA,kDAKA,GAAAlC,YAAA+B,GACA3B,KAAA+B,GAAA,GAAApC,GAAAC,EAAAmC,IAAA,OACA/B,KAAAgC,YAAApC,EAAAoC,YACAhC,KAAAwB,GAAA5B,EAAA4B,GACAxB,KAAAiC,EAAArC,EAAAqC,MACA,IAAA,gBAAArC,GACAI,KAAA+B,GAAA,GAAApC,GAAAC,EAAAmC,IAAA,OACA/B,KAAAgC,YAAApC,EAAAoC,YACAhC,KAAAwB,GAAA5B,EAAA4B,IAAA,EACAxB,KAAAiC,EAAArC,EAAAqC,MACA,CAAA,OAAAC,KAAAtC,EAKA,KAAA,iDAJAI,MAAAwB,GAAA,EACAxB,KAAAiC,KACAjC,KAAA+B,GAAA,GAAApC,KAMAkB,EAAAc,EAAAb,SAEAD,GAAAsB,YAAA,WACA,MAAAnC,MAAAiC,EAAAG,QAIAvB,EAAAwB,oBAAA,WAEA,IAAA,GADAC,MACAC,EAAA,EAAAC,EAAAxC,KAAA+B,GAAAQ,EAAAvC,KAAAiC,EAAAG,OAAAG,IAAAC,EAAAA,EAAAjB,IAAAvB,KAAAwB,IACAc,EAAAG,MAAAD,EAAApB,iBAAApB,KAAAiC,EAAAM,IAGA,OAAAD,IAGAzB,EAAA6B,YAAA,SAAAC,GACA,GAAAC,MAAAC,QAAAF,GACA,IAAA,GAAAJ,GAAA,EAAAA,EAAAI,EAAAP,OAAAG,IACAvC,KAAAiC,EAAAQ,KAAAE,EAAAJ,KAMA1B,EAAAiC,eAAA,SAAAC,GACA,GAAAA,YAAApB,GACA,GAAAoB,EAAAvB,KAAAxB,KAAAwB,GAEAxB,KAAA+B,GAAAgB,EAAAhB,GACA/B,KAAAwB,GAAAuB,EAAAvB,GACAxB,KAAAiC,EAAAc,EAAAd,EAAAe,MAAA,OACA,CACA,GAAAC,GAAA,GAAAvB,QAAA/B,YAAAK,KAAA+B,IAAAR,IAAAvB,KAAAwB,GAAAxB,KAAAmC,cACA,KAAAY,EAAAhB,GAAAV,QAAA4B,GAEAjD,KAAA0C,YAAAK,EAAAd,IAGAjC,KAAA+B,GAAAgB,EAAAhB,GACA/B,KAAAwB,GAAAuB,EAAAvB,GACAxB,KAAAiC,EAAAc,EAAAd,EAAAe,MAAA,MAMAnC,EAAAI,OAAA,WAQA,OANAc,GAAA/B,KAAA+B,GAAAhB,WACAiB,YAAAhC,KAAAgC,YACAR,GAAAxB,KAAAwB,GACAS,EAAAjC,KAAAiC,IAMAP,OAAAC,iBAAAA,KC3FA,WACA,YAGAD,QAAAwB,UAAA,SAAAtD,EAAAuD,GACA,GAAA,gBAAAvD,GAAA,CACA,GAAAwD,GAAApD,KAAAqD,gBAAAzD,EACAI,MAAAsD,SAAAF,EAAA,GACApD,KAAAuD,cAAAH,EAAA,OACA,CAAA,GAAA,gBAAAxD,GAWA,KAAA,IAAA4D,OAAA,8BATA,IADAxD,KAAAsD,SAAA1D,EACA,gBAAAuD,GACAnD,KAAAuD,cAAAJ,MACA,CAAA,OAAA,KAAAA,EAGA,KAAA,IAAAK,OAAA,sDAFAxD,MAAAuD,cAAA,IAWA,IAAAE,GAAA,OACAC,EAAA,+BACAC,EAAA,0CACAC,EAAA,2CACAC,EAAA,kEACAC,EAAA,mEACAC,EAAA,kBACAC,EAAA,mBACAC,EAAA,kBACAC,EAAA,WACAC,EAAA,eACAC,EAAA,iGACAC,EAAA,qDACAC,EAAA,yDACAC,EAAA,kGACAC,EAAA,8FACAC,EAAA,iHACAC,EAAA,4GAMA7D,EAAAa,OAAAwB,UAAApC,UAGA6D,EAAA,SAAA/E,GACA,GAAAgF,EAEA,IAAA,KAAAhF,EACA,MAAA,EACA,IAAAuE,EAAAU,KAAAjF,GACA,MAAAkF,IAGA,KAAA,IAAAlF,EAAAmF,OAAA,QAAA,CACA,IAAApB,EAAAkB,KAAAjF,KAAAmE,EAAAc,KAAAjF,GACA,KAAA,IAAA4D,OAAA,2BAGAoB,GAAArE,WAAAX,OACA,CACA,IAAAiE,EAAAgB,KAAAjF,GACA,KAAA,IAAA4D,OAAA,wCAGAoB,GAAArE,WAAAX,GAGA,MAAAgF,IAGAI,EAAA,SAAApF,GACA,GAAAgF,EAEA,IAAA,KAAAhF,EACA,MAAA,EACA,IAAAuE,EAAAU,KAAAjF,GACA,MAAAkF,IAGA,IAAAG,GAAArF,EAAAoD,MAAA,GAAA,EAEA,KAAA,IAAApD,EAAAmF,OAAA,QAAA,CACA,IAAAnB,EAAAiB,KAAAjF,KAAAoE,EAAAa,KAAAjF,GACA,KAAA,IAAA4D,OAAA,gCAGA,IAAAU,EAAAW,KAAAjF,GACA,MAAAW,YAAA0E,EAAA,IAGAL,GAAArE,WAAA0E,OACA,CACA,IAAAnB,EAAAe,KAAAjF,GACA,KAAA,IAAA4D,OAAA,6CAGAoB,GAAArE,WAAA0E,GAGA,MAAAL,IAGAM,EAAA,SAAAC,GACA,GAAAC,GAAAD,EAAAJ,OAAArB,EAIA,QAHAnD,WAAA4E,EAAAE,UAAA,EAAAD,EAAA,IACA7E,WAAA4E,EAAAE,UAAAD,EAAA,EAAAD,EAAA/C,OAAA,MAKAkD,EAAA,SAAAH,GACA,GAAAI,GAAAC,CAEA,IAAA,KAAAL,OAAA,KAAAA,GAAA,OAAAA,EACA,KAAA,IAAA3B,OAAA,wBAKA,IAFA2B,EAAAA,EAAAM,QAAAxB,EAAA,YAEAQ,EAAAI,KAAAM,GAAA,CACA,GAAAjF,GAAAuE,EAAAiB,KAAAP,GACAQ,EAAAzF,EAAA,GACA0F,EAAA1F,EAAA,EAEA,QAAA2F,EAAAF,GAAAE,EAAAD,IAEA,GAAAlB,EAAAG,KAAAM,GAAA,CACA,GAAAjF,GAAAwE,EAAAgB,KAAAP,GACAQ,EAAAzF,EAAA,GACA0F,EAAA1F,EAAA,EAEA,QAAA2F,EAAAF,GAAAE,EAAAD,IAGA,GAAAR,GAAAD,EAAAJ,OAAArB,EAGA0B,GAFAD,EAAAJ,OAAA,aAGAQ,EAAAJ,EAAAE,UAAA,EAAAD,EAAA,GACAI,EAAAL,EAAAE,UAAAD,EAAA,KAEAI,EAAAL,EAAAE,UAAA,EAAAD,EAAA,GACAG,EAAAJ,EAAAE,UAAAD,EAAA,GAIA,IAEA9B,GAAAC,EAFAuC,EAAAvB,EAAAM,KAAAU,GACAQ,EAAAvB,EAAAK,KAAAW,EAGA,IAAAM,IACAxC,EAAAuC,EAAAN,GACAS,MAAA1C,IACA,KAAA,IAAAE,OAAA,2BAIA,IAAAuC,IACAxC,EAAAsC,EAAAL,EAAAxC,MAAA,EAAAwC,EAAApD,OAAA,IACA4D,MAAAzC,IACA,KAAA,IAAAC,OAAA,gCAIA,YAAAtB,KAAAoB,OAAApB,KAAAqB,GACAD,EAAAC,OAEArB,KAAAoB,GACAA,EAAA0B,EAAAQ,QAEAtD,KAAAqB,GACAoB,EAAAY,GAAAhC,IAGAoB,EAAAY,GAAAP,EAAAQ,KAGAK,EAAA,SAAAI,GACA,GAAAC,IAAAjE,EAAA,GAAAkE,EAAA,GAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,EAAAC,EAAA,EAAAC,EAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA,GAAAC,GAAA,GAAAC,GAAA,GAAAC,GAAA,GAAAC,GAAA,IACAhH,EAAAqE,EAAAmB,KAAAO,GACAkB,EAAAjH,EAAA,GACAkH,EAAAlH,EAAA,EAGA,OAFAK,YAAA4G,GAAA9G,KAAAgH,IAAA,GAAAnB,EAAAkB,IAMAvG,GAAAwC,gBAAA,SAAA8B,GAGA,GAFAA,EAAAA,EAAAM,QAAAhC,EAAA,IAEAY,EAAAQ,KAAAM,GAEA,OAAA5E,WAAA4E,GAAA,EACA,IAAAb,EAAAO,KAAAM,GAAA,CAEA,GAAAmC,GAAAnC,EAAAnC,MAAA,GAAA,EAIA,OAHAkB,GAAAW,KAAAM,KACAmC,GAAA,MAEA,EAAA/G,WAAA+G,IACA,MAAAlD,GAAAS,KAAAM,GACAD,EAAAC,GAEAG,EAAAH,IAIAtE,EAAAQ,QAAA,SAAAkG,GACA,GAAAC,GAAAnH,KAAAoH,KAAApH,KAAAgH,IAAAE,EAAAjE,SAAA,GAAAjD,KAAAgH,IAAAE,EAAAhE,cAAA,IACAmE,EAAArH,KAAAoH,KAAApH,KAAAgH,IAAArH,KAAAsD,SAAA,GAAAjD,KAAAgH,IAAArH,KAAAuD,cAAA,GAEA,OAAAmE,GAAAF,EACA,EACAE,EAAAF,GACA,EAEA,GAIA3G,EAAAE,SAAA,WACA,MAAAf,MAAAuD,eAAA,EACAvD,KAAAsD,SAAA,MAAAtD,KAAAuD,cAAA,IAEAvD,KAAAsD,SAAA,MAAAjD,KAAAsH,IAAA3H,KAAAuD,eAAA,QCxOA,WACA,YAGA7B,QAAAkG,oBAAA,YAUA,IAAA/G,GAAAa,OAAAkG,oBAAA9G,UAIA+G,EAAA,SAAAC,GACA,MAAAzH,MAAA0H,IAAAD,GAAAzH,KAAA2H,QAGAC,EAAA,SAAAC,GACA,GAAAC,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,GAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,KACAC,EAAA,CAsBA,OApBAF,IAAA,EAEAE,EADAF,GAAA,GACA,GAEA7H,KAAAC,MAAA4H,EAAA,GAAA,GAGAA,IAAA,IAEAE,EADAF,IAAA,GACA,EAEA7H,KAAAW,OAAAkH,EAAA,GAAA,GAAA,IAIA,IAAAA,IAAA,IAAAA,IACAE,EAAA,KAKAC,WAAAhI,KAAAgH,IAAA,GAAA,GAAAe,EAAA,IACAE,UAAAH,EAAAC,KAIAG,EAAA,SAAA3I,GACA,GAAA4I,GAAA5I,CACA,iBAAAA,KACA4I,EAAA5I,EAAAmB,WAGA,IAAA0H,GAAA,IACA,IAAAD,EAAAE,QAAA,OAGAD,EAAAD,EAAAnD,UAAAmD,EAAAE,QAAA,KAAAF,EAAApG,QACAoG,EAAAA,EAAAnD,UAAA,EAAAmD,EAAAE,QAAA,MAGA,IAAAC,GAAAH,EAAAE,QAAA,IAEA,KAAA,IAAAC,EAAA,CAIA,IAHA,GAAAC,GAAAJ,EAAAK,YAAA,KAGAD,IAAAJ,EAAApG,OAAA,GACAoG,EAAAA,EAAAxF,MAAA,GAAA,GACA4F,EAAAJ,EAAAK,YAAA,IAIAF,KAAAH,EAAApG,OAAA,IACAoG,EAAAA,EAAAxF,MAAA,GAAA,IAIA,GAAA4B,GAAA,GAMA,OALA,MAAA4D,GAAA,OAAAA,IACA5D,EAAA4D,GAIA5D,EAAA6D,EAAAK,cAOAjI,GAAAkI,aAAA,SAAAnJ,EAAAoJ,GACA,GAAAC,GAAA,CACAC,UAAAF,IAAA,OAAAA,IAEAC,EADAD,EAAA,GACA,GAEAA,EAAA,EACA,EAEAA,EAKA,IAAAG,GAAAC,CACA,IAAA,IAAAxJ,EACA,MAAA,GAEA,IAAA,OAAAA,OAAAsC,KAAAtC,EACA,MAAA,QAAAA,EAAA,OAAA,WAGA,KAAAsJ,SAAAtJ,GACA,MAAAoG,OAAApG,GAAA,MAAAA,EAAAmB,UAGA,IAAAmH,GAAA7H,KAAAC,MAAAuH,EAAAxH,KAAAsH,IAAA/H,IAEAwJ,GAAAnB,EAAAC,GACAiB,EAAAvJ,EAAAwJ,EAAAf,YAEAH,GAAA,IAAAA,IAAA,MACAiB,EAAAA,EAAAE,cAAAJ,KAIA,IAAAE,EAAApI,WAAA2H,QAAA,OACAS,EAAAA,EAAAG,QAAAL,GAGA,IAAArE,GAAA2D,EAAAY,GACAb,EAAA,EAMA,OAJA,MAAA1D,GAAA,OAAAA,IACA0D,EAAAc,EAAAd,WAGA1D,EAAA0D,GAMAzH,EAAA0I,uBAAA,SAAA3J,EAAA4J,GACA,GAAA,OAAA5J,OAAAsC,KAAAtC,EACA,MAAA,QAAAA,EAAA,OAAA,WAGA,KAAAsJ,SAAAtJ,GACA,MAAAoG,OAAApG,GAAA,MAAAA,EAAAmB,UAGA,IAAA0I,EACA,IAAAP,SAAAM,IAAA,OAAAA,EAAA,CACA,GAAAE,GAAArJ,KAAAsH,IAAA/H,GAAAmB,WACA4I,EAAAD,EAAAhB,QAAA,KACAkB,GAAA,IAAAF,EAAAhB,QAAA,OAAA,IAAAgB,EAAAhB,QAAA,IAGAe,IADA,IAAAE,GAAAA,EAAAH,IAAAI,EACAhK,EAAAiK,YAAAL,GAEAA,EAAA,GAAA,GAAAA,GAAAA,EAAAE,EAAAtH,OAAAxC,EAAAiK,cAAAjK,EAAAiK,YAAAL,OAGAC,GAAA7J,EAAAiK,aAGA,OAAAtB,GAAAkB,IAMA5I,EAAAiJ,mBAAA,SAAAlK,EAAAmK,GACA,GAAA,OAAAnK,OAAAsC,KAAAtC,EACA,MAAA,QAAAA,EAAA,OAAA,WAGA,KAAAsJ,SAAAtJ,GACA,MAAAoG,OAAApG,GAAA,MAAAA,EAAAmB,UAKA,IAAAiJ,GAAA,GACAC,EAAArK,CACAA,GAAA,IACAoK,EAAA,IACAC,EAAA5J,KAAAsH,IAAA/H,GAGA,IAAAgF,GAAA,GAWA,OARAA,GAFAsE,SAAAa,IAAA,OAAAA,EACAA,EAAA,GAAA,GAAAA,EACAE,EAAAX,UAEAW,EAAAX,QAAAS,GAGAE,EAAAX,UAGAU,EAAApF,EAAAkE,kBCpNA,WAEA,GAAAoB,GAAAC,OAAAC,QACAC,KAAA,OACAC,QAAA,UACAC,MAAA,QACAC,OAAA,SACAC,OAAA,SACAC,OAAA,SACAC,KAAA,OACAC,MAAA,QACAC,MAAA,QACAC,MAAA,QACAC,OAAA,SACAC,OAAA,SACAC,cAAA,gBACAC,cAAA,gBACAC,OAAA,SACAC,KAAA,OACAC,UAAA,YACAC,KAAA,OACAC,QAAA,UACAC,MAAA,QACAC,eAAA,iBACAC,gBAAA,oBAIAC,EAAA,SAAAC,GACA,MAAAA,KAAA1B,EAAAa,QAAAa,IAAA1B,EAAAc,QAGAa,EAAA,SAAAD,GACA,OAAAA,GACA,IAAA1B,GAAAS,KACA,IAAAT,GAAAU,MACA,IAAAV,GAAAW,MACA,IAAAX,GAAAY,MACA,OAAA,CACA,SACA,OAAA,IAIAgB,EAAA,SAAAF,GACA,OAAAA,GACA,IAAA1B,GAAAK,MACA,IAAAL,GAAAM,OACA,IAAAN,GAAAO,OACA,IAAAP,GAAAQ,OACA,OAAA,CACA,SACA,OAAA,IAIAqB,EAAA,SAAAH,GACA,MAAAA,KAAA1B,EAAAY,OAAAc,IAAA1B,EAAAQ,QAGAsB,EAAA,SAAAJ,GACA,MAAAC,GAAAD,IAAAE,EAAAF,IAGAK,EAAA,SAAAL,GACA,MAAAA,KAAA1B,EAAAe,eAAAW,IAAA1B,EAAAgB,eAGAgB,EAAA,SAAAN,GACA,MAAAI,GAAAJ,IAAAK,EAAAL,IAAAD,EAAAC,IAGAO,EAAA,SAAAP,GACA,GAAAM,EAAAN,GACA,OAAA,CAGA,QAAAA,GACA,IAAA1B,GAAAG,KACA,IAAAH,GAAAI,QACA,IAAAJ,GAAAiB,OACA,IAAAjB,GAAAkB,KACA,IAAAlB,GAAAmB,UACA,IAAAnB,GAAAwB,gBACA,OAAA,EAGA,OAAA,GAYAU,EAAA,SAAAC,EAAAC,GAEA,MADAnC,QAAAoC,KAAAF,GACAjK,SAAAkK,GAGAE,EAAA,SAAAH,GACA,GAAAD,EAAAC,EAAA,GACA,KAAA,IAAA7I,OAAA6I,EAAAI,KAAA,yCAIAC,EAAA,SAAAL,GACA,MAAAA,GAAAI,OAAAvC,EAAAsB,OAGAmB,EAAA,SAAAN,GACA,GAAAO,GAAAP,EAAAO,OAEA,IAAA,OAAAA,GAAA,gBAAAA,GACA,KAAA,IAAApJ,OAAA,2CAGA,KAAA,IAAAsI,EAAAc,EAAAH,QAAA,IAAAV,EAAAa,EAAAH,MACA,KAAA,IAAAjJ,OAAA,6BAAAoJ,EAAAH,OAIAI,EAAA,SAAAR,GAEA,GAAAO,GAAAP,EAAAO,OAEA,KAAA,IAAAF,EAAAE,GACA,KAAA,IAAApJ,OAAA,0BAAAoJ,EAAAH,KAGAK,GAAAF,EAEA,IAAAG,GAAAV,EAAAU,IAEA,IAAA,gBAAAA,IAAA/G,MAAA+G,IAAAA,GAAA,EACA,KAAA,IAAAvJ,OAAA,gEAGA,IAAAwJ,GAAAX,EAAAY,IAEA,QAAA/K,KAAA8K,EAAA,CACA,IAAA,IAAApK,MAAAC,QAAAmK,GACA,KAAA,IAAAxJ,OAAA,2DAOA,KAAA,IAJAwJ,EAAAE,OAAA,SAAAC,EAAAC,GACA,MAAAD,IAAA,gBAAAC,IAAAA,GAAA,IACA,GAGA,KAAA,IAAA5J,OAAA,mEAKA6J,EAAA,SAAAhB,GACA,GAAAiB,GAAAjB,EAAAiB,OACAC,EAAAlB,EAAAO,OAEA,KAAA,IAAAhK,MAAAC,QAAAyK,GACA,KAAA,IAAA9J,OAAA,4DAOA,KAAA,IAJA8J,EAAAJ,OAAA,SAAAC,EAAAC,GACA,MAAAD,IAAA,gBAAAC,KACA,GAGA,KAAA,IAAA5J,OAAA,+DAGA,QAAAtB,KAAAqL,EAAA,CACA,IAAA,IAAA3K,MAAAC,QAAA0K,GACA,KAAA,IAAA/J,OAAA,6DAGA,IAAA8J,EAAAlL,SAAAmL,EAAAnL,OACA,KAAA,IAAAoB,OAAA,kFAGA,IAAAjB,GAAA,CACA,KACA,KAAAA,EAAAgL,EAAAnL,OAAAG,IAAA,CACA,GAAAiL,GAAAD,EAAAhL,EACAuK,GAAAU,IAEA,MAAA1L,GACA,KAAA,IAAA0B,OAAA,oEAAA1B,EAAA2L,YAKAC,EAAA,SAAArB,GACA,GAAAO,GAAAP,EAAAO,OAEA,QAAA1K,KAAA0K,EACA,KAAA,IAAApJ,OAAA0G,EAAAuB,eAAA,0CAGA,KAAA,IAAAS,EAAAU,EAAAH,MACA,KAAA,IAAAjJ,OAAA0G,EAAAuB,eAAA,mCAAAmB,EAAAH,KAAA,wBAIAK,EAAA,SAAAT,GAEA,GAAA,OAAAA,GAAA,gBAAAA,GAyBA,KAAA,IAAA7I,OAAA,qFAAA6I,EAxBA,IAAAsB,GAAAtB,EAAAI,IAEA,IAAAN,EAAAwB,GAGA,OAAAA,GACA,IAAAzD,GAAAoB,KACAqB,EAAAN,EACA,MACA,KAAAnC,GAAAsB,MACAqB,EAAAR,EACA,MACA,KAAAnC,GAAAqB,QACA8B,EAAAhB,EACA,MACA,KAAAnC,GAAAuB,eACAiC,EAAArB,EACA,MACA,SACA,KAAA,IAAA7I,OAAA,iBAAAmK,OAhBAnB,GAAAH,IA2BAuB,EAAA,SAAAvB,GACA,GAAA,gBAAAA,GACA,OAAAI,KAAAJ,EAGA,KAAA,GAAAwB,KAAAxB,GACA,GAAAA,EAAAyB,eAAAD,GAAA,CACA,GAAAjO,GAAAyM,EAAAwB,EACA,aAAAA,IACAjL,MAAAC,QAAAjD,GACAyM,EAAAwB,GAAAjO,EAAAmO,IAAAH,GAEAvB,EAAAwB,GAAAD,EAAAhO,IAMA,MAAAyM,IAGA2B,EAAA,SAAApO,GACA,MAAA,QAAAA,GAAA,gBAAAA,IAAAuM,EAAAvM,EAAA6M,MAIA7M,EAHAA,EAAA6M,MAMAwB,EAAA,SAAAJ,EAAAjO,GACA,MAAA,YAAAiO,GAAA,KAAAA,EACAjL,MAAAC,QAAAjD,GACAA,EAAAmO,IAAAC,GAGAA,EAAApO,GAEAA,GAIAsO,EAAA,SAAAC,EAAAC,GACA,MAAAxL,OAAAC,QAAAsL,IAAAvL,MAAAC,QAAAuL,GAEAD,EAAA/L,SAAAgM,EAAAhM,QAIA+L,EAAAjB,OAAA,SAAAmB,EAAAC,EAAA/L,GACA,MAAA8L,IAAAC,IAAAF,EAAA7L,KACA,GAGA4L,IAAAC,GAGAG,EAAA,SAAAC,EAAAC,GACA,OAAAvM,KAAAsM,GAAAA,IAAAC,EACA,OAAA,CAGA,IAAAD,YAAAE,IAAAD,YAAAC,GACA,MAAAF,GAAAG,OAAAF,EAGA,IAAA7L,MAAAC,QAAA2L,IAAA5L,MAAAC,QAAA4L,GAAA,CAKA,MAJAD,GAAAtB,OAAA,SAAAmB,EAAAC,EAAA/L,GACA,MAAA8L,IAAAC,EAAAK,OAAAF,EAAAlM,MACA,GAKA,OAAA,GAGAqM,EAAA,SAAAC,EAAAC,GACA,WAAA5M,KAAA2M,GAAAA,IAAAC,GAIAD,IAAAC,GAGAC,EAAA,SAAAC,EAAAC,GACA,WAAA/M,KAAA8M,GAAAA,IAAAC,GAIAD,EAAA5M,SAAA6M,EAAA7M,QAIA4M,EAAA9B,OAAA,SAAAmB,EAAAC,EAAA/L,GACA,MAAA8L,IAAAC,IAAAW,EAAA1M,KACA,IAKA2M,EAAA,SAAAC,GACA,GAAA9C,EAeA,OAdA,gBAAA8C,KAIA9C,EAHAF,EAAAgD,GAGAvN,KAAAC,MAAAsN,GAFAA,GAMA,OAAAA,GAAA,gBAAAA,KACA9C,EAAA8C,GAGA9C,EAAAuB,EAAAvB,IAMAqC,EAAA,SAAAS,GACA,GAAA9C,GAAA6C,EAAAC,EACArC,GAAAT,GACArM,KAAAoP,YAAA/C,GAGAgD,EAAA,SAAAzD,GACA,GAAA0D,GAAA,WACA,MAAAtP,MAAAoP,YAAA3C,OAAAb,EAGA,KACAzB,OAAAoF,eAAAD,EAAA,QACA1P,MAAA,KAAAgM,IAEA,MAAA9J,IAIA,MAAAwN,IAgBAzO,EAAA6N,EAAA5N,WAbA,SAAA0O,GACA,GAAA3O,GAAA2O,EAAA1O,SACA,KAAA,GAAA+M,KAAA3D,GACA,GAAAA,EAAA4D,eAAAD,GAAA,CACA,GAAAjC,GAAA1B,EAAA2D,GACA4B,EAAA,KAAA7D,CAEA/K,GAAA4O,GAAAJ,EAAAzD,KAQA8C,GAEA7N,EAAAI,OAAA,WACA,MAAAW,MAAA8N,UAAA1P,KAAAoP,cAGAvO,EAAA8O,YAAA,WACA,MAAA/N,MAAA8N,UAAA1P,KAAAoP,YAAAnB,IAGApN,EAAAqL,UAAA,WACA,MAAAA,GAAAlM,KAAAoP,YAAA3C,OAGA5L,EAAA8K,QAAA,WACA,MAAAA,GAAA3L,KAAAoP,YAAA3C,OAGA5L,EAAAgL,gBAAA,WACA,MAAAA,GAAA7L,KAAAoP,YAAA3C,OAGA5L,EAAAiL,kBAAA,WACA,MAAAA,GAAA9L,KAAAoP,YAAA3C,OAGA5L,EAAAkL,eAAA,WACA,MAAAA,GAAA/L,KAAAoP,YAAA3C,OAGA5L,EAAAmL,UAAA,WACA,MAAAA,GAAAhM,KAAAoP,YAAA3C,OAGA5L,EAAAoL,UAAA,WACA,MAAAA,GAAAjM,KAAAoP,YAAA3C,OAGA5L,EAAAsL,gBAAA,WACA,MAAAA,GAAAnM,KAAAoP,YAAA3C,OAGA5L,EAAA+O,UAAA,SAAA7C,EAAAE,GACA,GAAAjN,KAAA6C,UACA,KAAA,IAAAW,OAAA,sDAEAtB,KAAA6K,IACAA,EAAA,EAGA,IAAAH,GAAAhL,KAAAC,MAAA7B,KAAA2P,cAEA,OAAA,IAAAjB,IAAAjC,KAAAvC,EAAAsB,MAAAuB,KAAAA,EAAAH,QAAAA,EAAAK,KAAAA,KAIApM,EAAAgP,QAAA,WACA,MAAA7P,MAAAoP,YAAA3C,MAGA5L,EAAAiP,WAAA,WACA,OAAA5N,KAAAlC,KAAA+P,WACA,MAAA/P,MAAA+P,UAGA,IAAAnD,GAAA5M,KAAAoP,YAAAxC,OAWA,OATAhK,OAAAC,QAAA+J,GACA5M,KAAA+P,WAAAnD,EAAAmB,IAAA,SAAAiC,GACA,MAAA,IAAAtB,GAAAsB,KAGA,gBAAApD,IAAA,OAAAA,IACA5M,KAAA+P,WAAA,GAAArB,GAAA9B,IAGA5M,KAAA+P,YAGAlP,EAAAoP,QAAA,WACA,MAAAjQ,MAAAoP,YAAArC,MAGAlM,EAAAqP,QAAA,WACA,MAAAlQ,MAAAoP,YAAAnC,MAGApM,EAAAsP,UAAA,WACA,MAAAnQ,MAAAoP,YAAA9B,QAGAzM,EAAA8N,OAAA,SAAAyB,GACA,MAAAA,aAAA1B,KACA0B,EAAAP,YAAA7P,KAAA6P,cAIA3B,EAAAkC,EAAAD,YAAAnQ,KAAAmQ,iBAIA5B,EAAA6B,EAAAN,aAAA9P,KAAA8P,kBAIAlB,EAAAwB,EAAAH,UAAAjQ,KAAAiQ,cAIAlB,EAAAqB,EAAAF,UAAAlQ,KAAAkQ,gBAWAxO,OAAA2O,QAAAlG,OAAAC,QACAC,KAAA,GAAAqE,GAAA,UACApE,QAAA,GAAAoE,GAAA,aACAnE,MAAA,GAAAmE,GAAA,WACAlE,OAAA,GAAAkE,GAAA,YACAjE,OAAA,GAAAiE,GAAA,YACAhE,OAAA,GAAAgE,GAAA,YACA/D,KAAA,GAAA+D,GAAA,UACA9D,MAAA,GAAA8D,GAAA,WACA7D,MAAA,GAAA6D,GAAA,WACA5D,MAAA,GAAA4D,GAAA,WACA3D,OAAA,GAAA2D,GAAA,YACA1D,OAAA,GAAA0D,GAAA,YACAzD,cAAA,GAAAyD,GAAA,mBACAxD,cAAA,GAAAwD,GAAA,mBACAvD,OAAA,GAAAuD,GAAA,YACAtD,KAAA,GAAAsD,GAAA,UACArD,UAAA,GAAAqD,GAAA,eACAhD,gBAAA,GAAAgD,GAAA,uBAGAhN,OAAAgN,OAAAA,EACAhN,OAAA4O,YAAApG","file":"ni-data-types.min.js","sourcesContent":["//****************************************\n// NITimestamp data type\n// National Instruments Copyright 2016\n//****************************************\n\n(function () {\n    'use strict';\n\n    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n    var epochDiffInSeconds = 2082844800; //the difference between JS epoch (1970) and LV Epoch (1904) in seconds.\n    var JSEpochInSeconds = 62135596800;\n\n    /* A NITimestamp can be created with no param, and with different types of parameters:\n         1. a string in the format '123:567890' where\n             the first part is an INT64 serialized to a decimal string, representing the nr. of seconds realtive to LV Epoch\n             the second part is a INT 64 reprezenting the fractional part\n         2. a javascript Date\n         3. a double number\n         4. a NITimestamp\n    */\n    var NITimestamp = function (value) {\n        var timeInMilliSeconds, timeInSeconds, remainder;\n        this.epochDiffInSeconds = epochDiffInSeconds; // TODO verify it and make it private\n\n        if (typeof value === 'string') {\n            var parts = value.split(':');\n            this.seconds = Math.floor(parseFloat(parts[0]));\n            var fractionalPart = parseFloat(parts[1]);\n\n            if (fractionalPart > 18446744073709550000) {\n                fractionalPart = 18446744073709550000;\n            }\n\n            this.fractions = Math.ceil(fractionalPart / 2048) / (MAX_SAFE_INTEGER + 1);\n        } else if (value instanceof Date) {\n            timeInMilliSeconds = value.getTime();\n            timeInSeconds = Math.floor(timeInMilliSeconds / 1000);\n            this.seconds = timeInSeconds + this.epochDiffInSeconds;\n            // JS % operator returns negative result if divisor is negative. This makes it positive.\n            remainder = ((timeInMilliSeconds % 1000) + 1000) % 1000;\n            this.fractions = remainder / 1000;\n        } else if (typeof value === 'number') {\n            timeInSeconds = Math.floor(value);\n            this.seconds = timeInSeconds;\n            this.fractions = value - timeInSeconds;\n        } else if (value instanceof NITimestamp) {\n            /*copy the timestamp*/\n            this.seconds = value.seconds;\n            this.fractions = value.fractions;\n        } else {\n            this.seconds = 0.0;\n            this.fractions = 0.0;\n        }\n    };\n\n    var proto = NITimestamp.prototype;\n\n    proto.toString = function () {\n        return '' + Math.floor(this.seconds) + ':' + Math.round(this.fractions * (MAX_SAFE_INTEGER + 1) * 2048);\n    };\n\n    proto.toJSON = function () {\n        return this.toString();\n    };\n\n    proto.toDate = function () {\n        return new Date((this.seconds - this.epochDiffInSeconds + this.fractions) * 1000);\n    };\n\n    proto.valueOf = function () {\n        return this.seconds + this.fractions;\n    };\n\n    /*calculates the seconds passed since the Gregorian epoch for this timestamp*/\n    proto.toAbsoluteTime = function () {\n        return this.seconds + this.fractions + JSEpochInSeconds - epochDiffInSeconds;\n    };\n\n    proto.compare = function (timestamp) {\n        if (this.seconds < timestamp.seconds) {\n            return -1;\n        } else if (this.seconds > timestamp.seconds) {\n            return 1;\n        } else {\n            if (this.fractions < timestamp.fractions) {\n                return -1;\n            } else if (this.fractions > timestamp.fractions) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }\n    };\n\n    proto.add = function (dt) {\n        this.seconds += Math.floor(dt);\n        var fraction = dt - Math.floor(dt);\n        fraction += this.fractions;\n        if (fraction >= 1) {\n            fraction -= 1;\n            this.seconds += 1;\n        }\n\n        this.fractions = fraction;\n\n        return this; //enable chaining\n    };\n\n    window.NITimestamp = NITimestamp;\n}());\n","//****************************************\n// Analog Waveform data type\n// National Instruments Copyright 2016\n//****************************************\n\n(function () {\n    'use strict';\n    var NITimestamp = window.NITimestamp;\n\n    var NIAnalogWaveform = function (value) {\n        if (typeof value === 'string') {\n            try {\n                value = JSON.parse(value);\n            } catch (e) {\n                throw 'Can\\'t create an analog waveform from this value';\n            }\n            // falltrough, value is now an object parsed from the string,\n        }\n\n        if (value instanceof NIAnalogWaveform) {\n            this.t0 = new NITimestamp(value.t0 || '0:0');\n            this.channelName = value.channelName;\n            this.dt = value.dt;\n            this.Y = value.Y;\n        } else if (typeof value === 'object') {\n            this.t0 = new NITimestamp(value.t0 || '0:0');\n            this.channelName = value.channelName;\n            this.dt = value.dt || 0;\n            this.Y = value.Y;\n        } else if (value === undefined) {\n            this.dt = 0;\n            this.Y = [];\n            this.t0 = new NITimestamp();\n        } else {\n            throw 'Can\\'t create an analog waveform from this value';\n        }\n    };\n\n    var proto = NIAnalogWaveform.prototype;\n\n    proto.sampleCount = function () {\n        return this.Y.length;\n    };\n\n    // convert the waveform to an array of [timestamp, value] pairs\n    proto.toTimeAndValueArray = function () {\n        var res = [];\n        for (var i = 0, ts = this.t0; i < this.Y.length; i++, ts = ts.add(this.dt)) {\n            res.push([ts.toAbsoluteTime(), this.Y[i]]);\n        }\n\n        return res;\n    };\n\n    proto.appendArray = function (arr) {\n        if (Array.isArray(arr)) {\n            for (var i = 0; i < arr.length; i++) {\n                this.Y.push(arr[i]);\n            }\n        }\n    };\n\n    // append a waveform\n    proto.appendWaveform = function (waveform) {\n        if (waveform instanceof NIAnalogWaveform) {\n            if (waveform.dt !== this.dt) {\n                // we cannot merge two waveforms with different sampling rates. Discard the old one and use the new one.\n                this.t0 = waveform.t0;\n                this.dt = waveform.dt;\n                this.Y = waveform.Y.slice(0);\n            } else {\n                var expectedT0 = new window.NITimestamp(this.t0).add(this.dt * this.sampleCount());\n                if (waveform.t0.compare(expectedT0) === 0) {\n                    // append waveform data\n                    this.appendArray(waveform.Y);\n                } else {\n                    // we don't support gaps in waveforms yet\n                    this.t0 = waveform.t0;\n                    this.dt = waveform.dt;\n                    this.Y = waveform.Y.slice(0);\n                }\n            }\n        }\n    };\n\n    proto.toJSON = function () {\n        var aw = {\n            t0: this.t0.toString(),\n            channelName: this.channelName,\n            dt: this.dt,\n            Y: this.Y\n        }\n\n        return aw;\n    };\n\n    window.NIAnalogWaveform = NIAnalogWaveform;\n}());\n","//****************************************\n// NIComplex data type\n// National Instruments Copyright 2016\n//****************************************\n\n(function () {\n    'use strict';\n\n    // Constructor Function\n    window.NIComplex = function (value, imag) {\n        if (typeof value === 'string') {\n            var complexNumber = this.parseFromString(value);\n            this.realPart = complexNumber[0];\n            this.imaginaryPart = complexNumber[1];\n        } else if (typeof value === 'number') {\n            this.realPart = value;\n            if (typeof imag === 'number') {\n                this.imaginaryPart = imag;\n            } else if (typeof imag === 'undefined') {\n                this.imaginaryPart = 0;\n            } else {\n                throw new Error('Can\\'t create complex number: invalid imaginary part');\n            }\n\n        } else {\n            throw new Error('Can\\'t create complex number');\n        }\n    };\n\n    // Static Private Variables\n    var spaceRemovalRegex = /\\s+/g;\n    var middleSignRegex = /([^eE][-+])|([eE][-+][iInN])/;\n    var testRealRegex = /^[-+]?([0-9]+|[0-9]+\\.|[0-9]*\\.[0-9]+)$/;\n    var testImagRegex = /^[-+]?([0-9]*|[0-9]+\\.|[0-9]*\\.[0-9]+)i$/;\n    var testRealScientificNotationRegex = /^[-+]?([0-9]+|[0-9]+\\.|[0-9]+\\.|[0-9]*\\.[0-9]+)[eE][-+]?[0-9]+$/;\n    var testImagScientificNotationRegex = /^[-+]?([0-9]+|[0-9]+\\.|[0-9]+\\.|[0-9]*\\.[0-9]+)[eE][-+]?[0-9]+i$/;\n    var checkRealInfinityRegex = /^[-+]?Infinity$/;\n    var checkImagInfinityRegex = /^[-+]?Infinityi$/;\n    var transformInfinityRegex = /[iI]nf(inity)?/g;\n    var checkOnlyI = /^[-+]?i$/;\n    var checkNaN = /^[-+]?NaNi?$/;\n    var fastPathComplexRegex = /^[-+]?([0-9]+|[0-9]+\\.[0-9]+)([eE][-+]?[0-9]+)?[-+]([0-9]+|[0-9]+\\.[0-9]+)([eE][-+]?[0-9]+)?i$/;\n    var realPartOnlyRegex = /^[+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?$/;\n    var imaginaryPartOnlyRegex = /^[+\\-]?((?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?i$/;\n    var realPartSIRegex = /^([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)(Y|Z|E|P|T|G|M|k|c|m|u|n|p|f|a|z|y){1}(?!i)$/;\n    var imaginaryPartSIRegex = /^([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)(Y|Z|E|P|T|G|M|k|c|m|u|n|p|f|a|z|y){1}i$/;\n    var scientificAndSINotationRegex = /^([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?E)(?!i)([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?E)i$/;\n    var scientificAndSINotationReversedRegex = /^([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?E)i([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?E)$/;\n\n    // Static Public Functions\n    // None\n\n    // Prototype creation\n    var proto = window.NIComplex.prototype;\n\n    // Static Private Functions\n    var getRealPart = function (value) {\n        var result;\n\n        if (value === '') {\n            return 0;\n        } else if (checkNaN.test(value)) {\n            return NaN;\n        }\n\n        if (value.search(/[eE]/) === -1) {\n            if (!(testRealRegex.test(value) || checkRealInfinityRegex.test(value))) {\n                throw new Error('Invalid real part format');\n            }\n\n            result = parseFloat(value);\n        } else {\n            if (!testRealScientificNotationRegex.test(value)) {\n                throw new Error('Invalid real part scientific notation');\n            }\n\n            result = parseFloat(value);\n        }\n\n        return result;\n    };\n\n    var getImaginaryPart = function (value) {\n        var result;\n\n        if (value === '') {\n            return 0;\n        } else if (checkNaN.test(value)) {\n            return NaN;\n        }\n\n        var valueWithoutI = value.slice(0, -1); //removes the i at the end\n\n        if (value.search(/[eE]/) === -1) {\n            if (!(testImagRegex.test(value) || checkImagInfinityRegex.test(value))) {\n                throw new Error('Invalid imaginary part format');\n            }\n\n            if (checkOnlyI.test(value)) {\n                return parseFloat(valueWithoutI + '1');\n            }\n\n            result = parseFloat(valueWithoutI);\n        } else {\n            if (!testImagScientificNotationRegex.test(value)) {\n                throw new Error('Invalid imaginary part scientific notation');\n            }\n\n            result = parseFloat(valueWithoutI);\n        }\n\n        return result;\n    };\n\n    var fastParseFromString = function (complexString) {\n        var middleSignIndex = complexString.search(middleSignRegex);\n        var real = parseFloat(complexString.substring(0, middleSignIndex + 1));\n        var imag = parseFloat(complexString.substring(middleSignIndex + 1, complexString.length - 1));\n\n        return [real, imag];\n    };\n\n    var thoroughParseFromString = function (complexString) {\n        var realSubString, imagSubString;\n\n        if (complexString === '' || typeof complexString === 'undefined' || complexString === null) {\n            throw new Error('Invalid number format');\n        }\n\n        complexString = complexString.replace(transformInfinityRegex, 'Infinity');\n\n        if (scientificAndSINotationRegex.test(complexString)) {\n            var parts = scientificAndSINotationRegex.exec(complexString),\n                realPartCoefficient = parts[1],\n                imaginaryPartCoefficient = parts[2];\n\n            return [scientificToDecimal(realPartCoefficient), scientificToDecimal(imaginaryPartCoefficient)];\n        }\n        else if (scientificAndSINotationReversedRegex.test(complexString)) {\n            var parts = scientificAndSINotationReversedRegex.exec(complexString),\n                realPartCoefficient = parts[2],\n                imaginaryPartCoefficient = parts[1];\n\n            return [scientificToDecimal(realPartCoefficient), scientificToDecimal(imaginaryPartCoefficient)];\n        }\n\n        var middleSignIndex = complexString.search(middleSignRegex);\n        var imagIndex = complexString.search(/i[-+]|i$/);\n\n        if (middleSignIndex < imagIndex) {\n            realSubString = complexString.substring(0, middleSignIndex + 1);\n            imagSubString = complexString.substring(middleSignIndex + 1);\n        } else {\n            imagSubString = complexString.substring(0, middleSignIndex + 1);\n            realSubString = complexString.substring(middleSignIndex + 1);\n        }\n\n        // Checks if real and/or imaginary parts have SI prefixes\n        var realPartSITest = realPartSIRegex.test(realSubString),\n            imaginaryPartSITest = imaginaryPartSIRegex.test(imagSubString),\n            realPart, imaginaryPart;\n\n        if (realPartSITest) {\n            realPart = scientificToDecimal(realSubString);\n            if (isNaN(realPart)) {\n                throw new Error('Invalid real part format');\n            }\n        }\n\n        if (imaginaryPartSITest) {\n            imaginaryPart = scientificToDecimal(imagSubString.slice(0, imagSubString.length - 1));\n            if (isNaN(imaginaryPart)) {\n                throw new Error('Invalid imaginary part format');\n            }\n        }\n\n        if (realPart !== undefined && imaginaryPart !== undefined) {\n            return [realPart, imaginaryPart];\n        }\n        else if (realPart !== undefined) {\n            return [realPart, getImaginaryPart(imagSubString)];\n        }\n        else if (imaginaryPart !== undefined) {\n            return [getRealPart(realSubString), imaginaryPart];\n        }\n\n        return [getRealPart(realSubString), getImaginaryPart(imagSubString)];\n    };\n\n    var scientificToDecimal = function (scientificValue) {\n        var prefixesToPowers = { 'Y': 24, 'Z': 21, 'E': 18, 'P': 15, 'T': 12, 'G': 9, 'M': 6, 'k': 3, 'c': -2, 'm': -3, 'u': -6, 'n': -9, 'p': -12, 'f': -15, 'a': -18, 'z': -21, 'y': -24 },\n            parts = realPartSIRegex.exec(scientificValue),\n            numericPart = parts[1],\n            prefix = parts[2],\n            number = parseFloat(numericPart) * (Math.pow(10, prefixesToPowers[prefix]));\n\n        return number;\n    };\n\n    // Public Prototype Methods\n    proto.parseFromString = function (complexString) {\n        complexString = complexString.replace(spaceRemovalRegex, '');\n\n        if (realPartOnlyRegex.test(complexString)) {\n            // if only real part has been passed in the string\n            return [parseFloat(complexString), 0];\n        } else if (imaginaryPartOnlyRegex.test(complexString)) {\n            // if only imaginary part has been passed in the string\n            var numericPartOfImaginary = complexString.slice(0, -1);\n            if (checkOnlyI.test(complexString)) {\n                numericPartOfImaginary += '1';\n            }\n            return [0, parseFloat(numericPartOfImaginary)];\n        } else if (fastPathComplexRegex.test(complexString)) {\n            return fastParseFromString(complexString);\n        } else {\n            return thoroughParseFromString(complexString);\n        }\n    };\n\n    proto.compare = function (complexNumb) {\n        var complexNumbMagnitute = Math.sqrt(Math.pow(complexNumb.realPart, 2) + Math.pow(complexNumb.imaginaryPart, 2));\n        var thisMagnitute = Math.sqrt(Math.pow(this.realPart, 2) + Math.pow(this.imaginaryPart, 2));\n\n        if (thisMagnitute > complexNumbMagnitute) {\n            return 1;\n        } else if (thisMagnitute < complexNumbMagnitute) {\n            return -1;\n        } else {\n            return 0;\n        }\n    };\n\n    proto.toString = function () {\n        if (this.imaginaryPart >= 0) {\n            return this.realPart + ' + ' + this.imaginaryPart + 'i';\n        } else {\n            return this.realPart + ' - ' + Math.abs(this.imaginaryPart) + 'i';\n        }\n    };\n}());\n","//****************************************\n// NINumeric data type\n// National Instruments Copyright 2016\n//****************************************\n\n(function () {\n    'use strict';\n\n    // Constructor function\n    window.NINumericFormatters = function () {\n    };\n\n    // Static Private Variables\n    // None\n\n    // Static Public Functions\n    // None\n\n    // Prototype creation\n    var proto = window.NINumericFormatters.prototype;\n\n    // Static Private Functions\n    // Some browsers(PhantomJS, IE) dont support Math.log10(x)\n    var getLog10 = function (x) {\n        return Math.log(x) * Math.LOG10E;\n    };\n\n    var getExtension = function (exponent) {\n        var extensionTable = ['y', 'z', 'a', 'f', 'p', 'n', 'μ', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'];\n        var index = 8;\n\n        if (exponent >= 3) {\n            if (exponent >= 24) {\n                index = 16;\n            } else {\n                index = Math.floor(exponent / 3) + 8;\n            }\n        } else {\n            if (exponent <= -3) {\n                if (exponent <= -24) {\n                    index = 0;\n                } else {\n                    index = Math.round((exponent - 1) / 3) + 8;\n                }\n            }\n\n            if (exponent === -2 || exponent === -1) {\n                index = 7;\n            }\n        }\n\n        return {\n            conversion: Math.pow(10, (index - 8) * 3),\n            extension: extensionTable[index]\n        };\n    };\n\n    var removeLastZero = function (value) {\n        var numberStr = value;\n        if (typeof value !== 'string') {\n            numberStr = value.toString();\n        }\n\n        var exp = '';\n        var exponential = numberStr.indexOf('e') !== -1;\n        //split the number into mantissa and exponent\n        if (exponential) {\n            exp = numberStr.substring(numberStr.indexOf('e'), numberStr.length);\n            numberStr = numberStr.substring(0, numberStr.indexOf('e'));\n        }\n\n        var dotIndex = numberStr.indexOf('.');\n        //remove 0s\n        if (dotIndex !== -1) {\n            var lastZero = numberStr.lastIndexOf('0');\n\n            //remove 0s one by one\n            while (lastZero === numberStr.length - 1) {\n                numberStr = numberStr.slice(0, -1);\n                lastZero = numberStr.lastIndexOf('0');\n            }\n\n            //delete the dot if is last\n            if (dotIndex === numberStr.length - 1) {\n                numberStr = numberStr.slice(0, -1);\n            }\n        }\n\n        var result = '0';\n        if (numberStr !== '0' && numberStr !== '-0') {\n            result = numberStr;\n        }\n\n        //rebuild the number\n        return result + exp.toUpperCase();\n    };\n\n    // Public Prototype Methods\n    // toSiNotation(1.5e-8, 3) returns '15n'\n    // toSiNotation(1.5, 1) returns '1.5'\n    // toSiNotation(-1.5e12, 3) returns '-1.500T'\n    proto.toSiNotation = function (value, nrOfDecimals) {\n        var decimals = 0;\n        if (isFinite(nrOfDecimals) && nrOfDecimals !== null) {\n            if (nrOfDecimals > 20) {\n                decimals = 20;\n            } else {\n                if (nrOfDecimals < 0) {\n                    decimals = 0;\n                } else {\n                    decimals = nrOfDecimals;\n                }\n            }\n        }\n\n        var mantissa, extensionData;\n        if (value === 0) {\n            return '0';\n        } else {\n            if (value === null || value === undefined) {\n                return (value === null) ? 'null' : 'undefined';\n            }\n\n            if (!isFinite(value)) {\n                return isNaN(value) ? 'NaN' : value.toString();\n            }\n\n            var exponent = Math.floor(getLog10(Math.abs(value)));\n\n            extensionData = getExtension(exponent);\n            mantissa = value / extensionData.conversion;\n\n            if (exponent >= 45 || exponent <= -45) {\n                mantissa = mantissa.toExponential(decimals);\n            }\n        }\n\n        if (mantissa.toString().indexOf('e') === -1) {\n            mantissa = mantissa.toFixed(decimals);\n        }\n\n        var result = removeLastZero(mantissa),\n            extension = '';\n\n        if (result !== '0' && result !== '-0') {\n            extension = extensionData.extension;\n        }\n\n        return result + extension;\n    };\n\n    // toDecPrecision(1000, 2) returns '1E+3'\n    // toDecPrecision(-1.212E-21, 3) returns '-1.2E-21'\n    // toDecPrecision(1100.5, 4) returns '1101'\n    proto.toDecPrecisionNotation = function (value, nrOfDigits) {\n        if (value === null || value === undefined) {\n            return value === null ? 'null' : 'undefined';\n        }\n\n        if (!isFinite(value)) {\n            return isNaN(value) ? 'NaN' : value.toString();\n        }\n\n        var partialVal;\n        if (isFinite(nrOfDigits) && nrOfDigits !== null) {\n            var stringValue = Math.abs(value).toString();\n            var dotPosition = stringValue.indexOf('.');\n            var eNotation = (stringValue.indexOf('e') !== -1) || (stringValue.indexOf('E') !== -1);\n\n            if (dotPosition !== -1 && dotPosition < nrOfDigits && !eNotation) {\n                partialVal = value.toPrecision(nrOfDigits);\n            } else {\n                partialVal = (nrOfDigits < 1 || 21 < nrOfDigits || nrOfDigits > stringValue.length) ? value.toPrecision() : value.toPrecision(nrOfDigits);\n            }\n        } else {\n            partialVal = value.toPrecision();\n        }\n\n        return removeLastZero(partialVal);\n    };\n\n    // toDecFixedNotation(1000, 2) returns '1000.00'\n    // toDecFixedNotation(20.49, 0) returns '20'\n    // toDecFixedNotation(-1.2E-20, 20) returns '-0.00000000000000000001'\n    proto.toDecFixedNotation = function (value, nrOfecimals) {\n        if (value === null || value === undefined) {\n            return value === null ? 'null' : 'undefined';\n        }\n\n        if (!isFinite(value)) {\n            return isNaN(value) ? 'NaN' : value.toString();\n        }\n\n        // toFixed(decimals) on negative numbers represented in\n        // scientific notation(ex: -100E21) is returning a number(-1000000...) not a string('-1e+23')\n        var sign = '';\n        var number = value;\n        if (value < 0) {\n            sign = '-';\n            number = Math.abs(value);\n        }\n\n        var result = '0';\n        if (isFinite(nrOfecimals) && nrOfecimals !== null) {\n            if (nrOfecimals < 0 || 20 < nrOfecimals) {\n                result = number.toFixed();\n            } else {\n                result = number.toFixed(nrOfecimals);\n            }\n        } else {\n            result = number.toFixed();\n        }\n\n        return sign + result.toUpperCase();\n    };\n}());\n","\n(function () {\n\n    var TypeNames = Object.freeze({\n        VOID: 'Void',\n        BOOLEAN: 'Boolean',\n        UINT8: 'UInt8',\n        UINT16: 'UInt16',\n        UINT32: 'UInt32',\n        UINT64: 'UInt64',\n        INT8: 'Int8',\n        INT16: 'Int16',\n        INT32: 'Int32',\n        INT64: 'Int64',\n        SINGLE: 'Single',\n        DOUBLE: 'Double',\n        COMPLEXSINGLE: 'ComplexSingle',\n        COMPLEXDOUBLE: 'ComplexDouble',\n        STRING: 'String',\n        PATH: 'Path',\n        TIMESTAMP: 'Timestamp',\n        ENUM: 'Enum',\n        CLUSTER: 'Cluster',\n        ARRAY: 'Array',\n        ANALOGWAVEFORM: 'AnalogWaveform',\n        DIGITALWAVEFORM: 'DigitalWaveform'\n    });\n\n    // Numeric helper functions\n    var isFloat = function (typeName) {\n        return typeName === TypeNames.SINGLE || typeName === TypeNames.DOUBLE;\n    };\n\n    var isSignedInteger = function (typeName) {\n        switch (typeName) {\n            case TypeNames.INT8:\n            case TypeNames.INT16:\n            case TypeNames.INT32:\n            case TypeNames.INT64:\n                return true;\n            default:\n                return false;\n        }\n    };\n\n    var isUnsignedInteger = function (typeName) {\n        switch (typeName) {\n            case TypeNames.UINT8:\n            case TypeNames.UINT16:\n            case TypeNames.UINT32:\n            case TypeNames.UINT64:\n                return true;\n            default:\n                return false;\n        }\n    };\n\n    var is64BitInteger = function (typeName) {\n        return typeName === TypeNames.INT64 || typeName === TypeNames.UINT64;\n    };\n\n    var isInteger = function (typeName) {\n        return isSignedInteger(typeName) || isUnsignedInteger(typeName);\n    };\n\n    var isComplex = function (typeName) {\n        return typeName === TypeNames.COMPLEXSINGLE || typeName === TypeNames.COMPLEXDOUBLE;\n    };\n\n    var isNumeric = function (typeName) {\n        return isInteger(typeName) || isComplex(typeName) || isFloat(typeName);\n    };\n\n    var isAggregateType = function (typeName) {\n        if (isNumeric(typeName)) {\n            return false;\n        }\n\n        switch (typeName) {\n            case TypeNames.VOID:\n            case TypeNames.BOOLEAN:\n            case TypeNames.STRING:\n            case TypeNames.PATH:\n            case TypeNames.TIMESTAMP:\n            case TypeNames.DIGITALWAVEFORM:\n                return false;\n        }\n\n        return true;\n    };\n\n    // Validation methods\n    var throwIfInvalidProperties = function (descriptor, propertyCount, errorMessage) {\n        var descriptorKeys = Object.keys(descriptor);\n\n        if(descriptorKeys.length !== propertyCount) {\n            throw new Error(errorMessage);\n        }\n    };\n\n    var validProperties = function (descriptor, propertyCount) {\n        var descriptorKeys = Object.keys(descriptor);\n        return descriptorKeys.length !== propertyCount;\n    };\n\n    var validatePrimitives = function (descriptor) {\n        if (validProperties(descriptor, 1)) {\n            throw new Error(descriptor.name + ' must only have the property \"name\".');\n        }\n    };\n\n    var isValidArraySubtype = function (descriptor) {\n        return descriptor.name !== TypeNames.ARRAY;\n    };\n\n    var validateEnum = function (descriptor) {\n        var subtype = descriptor.subtype;\n\n        if(subtype === null || typeof subtype !== 'object') {\n            throw new Error('Enum subtype must be a valid descriptor.');\n        }\n\n        if(isUnsignedInteger(subtype.name) === false || is64BitInteger(subtype.name) === true) {\n            throw new Error('Enum unsupported subtype: ' + subtype.name);\n        }\n    };\n\n    var validateArray = function (descriptor) {\n\n        var subtype = descriptor.subtype;\n\n        if (isValidArraySubtype(subtype) === false) {\n            throw new Error('Invalid Array subtype: ' + subtype.name);\n        }\n\n        validateType(subtype);\n\n        var rank = descriptor.rank;\n\n        if (typeof rank !== 'number' || isNaN(rank) || rank <= 0) {\n            throw new Error('Array type property \"rank\" must be an integer greater than 0.');\n        }\n\n        var arrayFixedSize = descriptor.size;\n\n        if (arrayFixedSize !== undefined) {\n            if (Array.isArray(arrayFixedSize) === false) {\n                throw new Error('Array type property \"size\" must be an array of integers.');\n            }\n\n            var allElementsAreNumbersGreaterThanZero = arrayFixedSize.reduce(function (prev, curr){\n                return prev && typeof curr == 'number' && curr >= 0;\n            }, true);\n\n            if (allElementsAreNumbersGreaterThanZero === false) {\n                throw new Error('Array type property \"size\" must contain only natural numbers.');\n            }\n        }\n    };\n\n    var validateCluster = function (descriptor) {\n        var fields = descriptor.fields;\n        var fieldTypes = descriptor.subtype;\n\n        if (Array.isArray(fields) === false) {\n            throw new Error('Cluster type must have a \"fields\" property of type array.');\n        }\n\n        var allFieldsAreStrings = fields.reduce(function(prev, curr) {\n            return prev && typeof curr === 'string';\n        }, true);\n\n        if(allFieldsAreStrings === false) {\n            throw new Error('Cluster type property \"fields\", must be an array of strings.');\n        }\n\n        if (fieldTypes !== undefined) {\n            if (Array.isArray(fieldTypes) === false) {\n                throw new Error('Cluster type property \"subtype\" must be an array of types.');\n            }            \n\n            if (fields.length !== fieldTypes.length) {\n                throw new Error('Cluster properties \"fields\" and \"subtype\", must be arrays with the same length.');\n            }\n            \n            var i = 0;\n            try {\n                for (; i < fieldTypes.length; i++) {\n                    var fieldType = fieldTypes[i];\n                    validateType(fieldType);\n                }\n            } catch (e) {\n                throw new Error('Cluster property \"subtype\" contains an invalid type descriptor.\\n' + e.message);\n            }\n        }\n    };\n\n    var validateAnalogWaveform = function (descriptor) {\n        var subtype = descriptor.subtype;\n\n        if (subtype === undefined) {\n            throw new Error(TypeNames.ANALOGWAVEFORM + ' must have a property called \"subtype\".');\n        }\n\n        if (isNumeric(subtype.name) === false) {\n            throw new Error(TypeNames.ANALOGWAVEFORM + ' subtype only accepts numerics. ' + subtype.name + ' was found instead.');\n        }\n    };\n\n    var validateType = function (descriptor) {\n\n        if (descriptor !== null && typeof descriptor === 'object') {\n            var type = descriptor.name;\n\n            if (!isAggregateType(type)) {\n                validatePrimitives(descriptor);\n            } else {\n                switch (type) {\n                    case TypeNames.ENUM:\n                        validateEnum(descriptor);\n                        break;\n                    case TypeNames.ARRAY:\n                        validateArray(descriptor);\n                        break;\n                    case TypeNames.CLUSTER:\n                        validateCluster(descriptor);\n                        break;\n                    case TypeNames.ANALOGWAVEFORM:\n                        validateAnalogWaveform(descriptor);\n                        break;\n                    default:\n                        throw new Error('Unknown type: ' + type);\n                }\n            }\n\n        } else {\n            throw new Error('Descriptor should be a JSON encoded string or a valid format Object. Value found: ' + descriptor);\n        }\n        \n    };\n\n    // Short-type notation handling\n    var wrapShortTypes = function (descriptor) {\n        if (typeof descriptor === 'string') {\n            return {name: descriptor};\n        }\n\n        for(var key in descriptor) {\n            if (descriptor.hasOwnProperty(key)) {\n                var value = descriptor[key];\n                if (key === 'subtype') {\n                    if (Array.isArray(value)) {\n                        descriptor[key] = value.map(wrapShortTypes);\n                    } else {\n                        descriptor[key] = wrapShortTypes(value);\n                    }\n                }\n            }\n        }\n\n        return descriptor;\n    };\n\n    var unwrapShortType = function (value) {\n        if (value !== null && typeof value === 'object' && !isAggregateType(value.name)) {\n            return value.name;\n        }\n\n        return value;\n    };\n\n    var encodeShortType = function (key, value) {\n        if (key === 'subtype' || key === '') { // Outermost key is always '' (empty string)\n            if (Array.isArray(value)) {\n                return value.map(unwrapShortType);\n            }\n\n            return unwrapShortType(value);\n        }\n        return value;\n    };\n\n    // Equals helper methods\n    var fieldsEqual = function (fields1, fields2) {\n        if (Array.isArray(fields1) && Array.isArray(fields2)) {\n\n            if (fields1.length !== fields2.length) {\n                return false;\n            }\n\n            return fields1.reduce(function (pv, cv, i) {\n                return pv && cv === fields2[i];\n            }, true);\n        }\n\n        return fields1 === fields2;\n    };\n\n    var subtypesEqual = function (subtype1, subtype2) {\n        if (subtype1 === undefined && subtype1 === subtype2) {\n            return true;\n        }\n\n        if (subtype1 instanceof NIType && subtype2 instanceof NIType) {\n            return subtype1.equals(subtype2);\n        }\n\n        if (Array.isArray(subtype1) && Array.isArray(subtype2)) {\n            var areEqual = subtype1.reduce(function (pv, cv, i) {\n                return pv && cv.equals(subtype2[i]);\n            }, true);\n\n            return areEqual;\n        }\n\n        return false;\n    };\n\n    var ranksEqual = function (rank1, rank2) {\n        if (rank1 === undefined && rank1 === rank2) {\n            return true;\n        }\n\n        return rank1 === rank2;\n    };\n\n    var sizesEqual = function (sizes1, sizes2) {\n        if (sizes1 === undefined && sizes1 === sizes2) {\n            return true;\n        }\n\n        if (sizes1.length !== sizes2.length) {\n            return false;\n        }\n\n        var areAllSizesEqual = sizes1.reduce(function (pv, cv, i) {\n            return pv && cv === sizes2[i];\n        }, true);\n\n        return areAllSizesEqual;\n    };\n\n    var parseDescriptor = function (descriptorValue) {\n        var descriptor;\n        if (typeof descriptorValue === 'string') {\n            if (!isAggregateType(descriptorValue)) {\n                descriptor = descriptorValue;\n            } else {\n                descriptor = JSON.parse(descriptorValue);\n            }\n        }\n\n        if (descriptorValue !== null && typeof descriptorValue === 'object') {\n            descriptor = descriptorValue;\n        }\n\n        descriptor = wrapShortTypes(descriptor);\n\n        return descriptor;\n    };\n\n    // Constructor\n    var NIType = function (descriptorValue) {\n        var descriptor = parseDescriptor(descriptorValue);\n        validateType(descriptor);\n        this._descriptor = descriptor;\n    };\n\n    var generateTypeCheker = function (typeName) {\n        var typeChecker = function () {\n            return this._descriptor.name === typeName;\n        };\n\n        try {\n            Object.defineProperty(typeChecker, 'name', {\n                value : 'is' + typeName\n            });\n        } catch (e) {\n            // Browser might not support this.\n        }\n\n        return typeChecker;\n    };\n\n    var addQueries = function (typeDescriptorObject) {\n        var proto = typeDescriptorObject.prototype;\n        for(var key in TypeNames) {\n            if (TypeNames.hasOwnProperty(key)) {\n                var typeName = TypeNames[key];\n                var isQuery = 'is' + typeName;\n\n                proto[isQuery] = generateTypeCheker(typeName);\n            }\n        }\n    };\n\n    // Public instance methods\n    var proto = NIType.prototype;\n\n    addQueries(NIType);\n\n    proto.toJSON = function () {\n        return JSON.stringify(this._descriptor);\n    };\n\n    proto.toShortJSON = function () {\n        return JSON.stringify(this._descriptor, encodeShortType);\n    };\n\n    proto.isNumeric = function () {\n        return isNumeric(this._descriptor.name);\n    };\n\n    proto.isFloat = function () {\n        return isFloat(this._descriptor.name);\n    };\n\n    proto.isSignedInteger = function () {\n        return isSignedInteger(this._descriptor.name);\n    };\n\n    proto.isUnsignedInteger = function () {\n        return isUnsignedInteger(this._descriptor.name);\n    };\n\n    proto.is64BitInteger = function () {\n        return is64BitInteger(this._descriptor.name);\n    };\n\n    proto.isInteger = function () {\n        return isInteger(this._descriptor.name);\n    };\n\n    proto.isComplex = function () {\n        return isComplex(this._descriptor.name);\n    };\n\n    proto.isAggregateType = function() {\n        return isAggregateType(this._descriptor.name);\n    }\n\n    proto.makeArray = function (rank, size) {\n        if (this.isArray()) {\n            throw new Error('Not possible to create an array from an array.');\n        } else {\n            if (rank === undefined) {\n                rank = 1;\n            }\n\n            var subtype = JSON.parse(this.toShortJSON());\n\n            return new NIType({name: TypeNames.ARRAY, rank: rank, subtype: subtype, size: size});\n        }\n    };\n\n    proto.getName = function () {\n        return this._descriptor.name;\n    };\n\n    proto.getSubtype = function () {\n        if (this._nisubtype !== undefined) {\n            return this._nisubtype;\n        }\n\n        var subtype = this._descriptor.subtype;\n\n        if (Array.isArray(subtype)) {\n            this._nisubtype = subtype.map(function (v) {\n                return new NIType(v);\n            });\n\n        } else if (typeof subtype === 'object' && subtype !== null) {\n            this._nisubtype = new NIType(subtype);\n        }\n\n        return this._nisubtype;\n    };\n\n    proto.getRank = function () {\n        return this._descriptor.rank;\n    };\n\n    proto.getSize = function () {\n        return this._descriptor.size;\n    };\n\n    proto.getFields = function () {\n        return this._descriptor.fields;\n    };\n\n    proto.equals = function (typeDescriptor) {\n        if (typeDescriptor instanceof NIType) {\n            if (typeDescriptor.getName() !== this.getName()) {\n                return false;\n            }\n\n            if (!fieldsEqual(typeDescriptor.getFields(), this.getFields())) {\n                return false;\n            }\n\n            if (!subtypesEqual(typeDescriptor.getSubtype(), this.getSubtype())) {\n                return false;\n            }\n\n            if (!ranksEqual(typeDescriptor.getRank(), this.getRank())) {\n                return false;\n            }\n\n            if (!sizesEqual(typeDescriptor.getSize(), this.getSize())) {\n                return false;\n            }\n\n            return true;\n        }\n\n        return false;\n    };\n\n    // Exports\n    window.NITypes = Object.freeze({\n        VOID: new NIType('\"Void\"'),\n        BOOLEAN: new NIType('\"Boolean\"'),\n        UINT8: new NIType('\"UInt8\"'),\n        UINT16: new NIType('\"UInt16\"'),\n        UINT32: new NIType('\"UInt32\"'),\n        UINT64: new NIType('\"UInt64\"'),\n        INT8: new NIType('\"Int8\"'),\n        INT16: new NIType('\"Int16\"'),\n        INT32: new NIType('\"Int32\"'),\n        INT64: new NIType('\"Int64\"'),\n        SINGLE: new NIType('\"Single\"'),\n        DOUBLE: new NIType('\"Double\"'),\n        COMPLEXSINGLE: new NIType('\"ComplexSingle\"'),\n        COMPLEXDOUBLE: new NIType('\"ComplexDouble\"'),\n        STRING: new NIType('\"String\"'),\n        PATH: new NIType('\"Path\"'),\n        TIMESTAMP: new NIType('\"Timestamp\"'),\n        DIGITALWAVEFORM: new NIType('\"DigitalWaveform\"')\n    });\n\n    window.NIType = NIType;\n    window.NITypeNames = TypeNames;\n}());\n"]}