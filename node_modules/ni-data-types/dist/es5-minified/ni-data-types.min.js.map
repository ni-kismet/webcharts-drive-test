{"version":3,"sources":["niTimeStamp.js","niAnalogWaveform.js","niComplex.js","niNumericFormatters.js","niType.js"],"names":["MAX_SAFE_INTEGER","Number","NITimestamp","value","timeInMilliSeconds","timeInSeconds","remainder","this","epochDiffInSeconds","parts","split","seconds","Math","floor","parseFloat","fractionalPart","fractions","ceil","Date","getTime","proto","prototype","toString","round","toJSON","toDate","valueOf","toAbsoluteTime","compare","timestamp","add","dt","fraction","window","NIAnalogWaveform","JSON","parse","e","t0","channelName","Y","undefined","sampleCount","length","toTimeAndValueArray","res","i","ts","push","appendArray","arr","Array","isArray","appendWaveform","waveform","slice","expectedT0","NIComplex","imag","complexNumber","parseFromString","realPart","imaginaryPart","Error","spaceRemovalRegex","middleSignRegex","testRealRegex","testImagRegex","testRealScientificNotationRegex","testImagScientificNotationRegex","checkRealInfinityRegex","checkImagInfinityRegex","transformInfinityRegex","checkOnlyI","checkNaN","fastPathComplexRegex","realPartOnlyRegex","imaginaryPartOnlyRegex","realPartSIRegex","imaginaryPartSIRegex","scientificAndSINotationRegex","scientificAndSINotationReversedRegex","getRealPart","result","test","NaN","search","getImaginaryPart","valueWithoutI","fastParseFromString","complexString","middleSignIndex","substring","thoroughParseFromString","realSubString","imagSubString","replace","exec","realPartCoefficient","imaginaryPartCoefficient","scientificToDecimal","realPartSITest","imaginaryPartSITest","isNaN","scientificValue","prefixesToPowers","Z","E","P","T","G","M","k","c","m","u","n","p","f","a","z","y","numericPart","prefix","pow","numericPartOfImaginary","complexNumb","complexNumbMagnitute","sqrt","thisMagnitute","abs","NINumericFormatters","getLog10","x","log","LOG10E","getExtension","exponent","extensionTable","index","conversion","extension","removeLastZero","numberStr","exp","indexOf","dotIndex","lastZero","lastIndexOf","toUpperCase","toSiNotation","nrOfDecimals","decimals","isFinite","mantissa","extensionData","toExponential","toFixed","toDecPrecisionNotation","nrOfDigits","partialVal","stringValue","dotPosition","eNotation","toPrecision","toDecFixedNotation","nrOfecimals","sign","number","TypeNames","Object","freeze","VOID","BOOLEAN","UINT8","UINT16","UINT32","UINT64","INT8","INT16","INT32","INT64","SINGLE","DOUBLE","COMPLEXSINGLE","COMPLEXDOUBLE","STRING","PATH","TIMESTAMP","ENUM","CLUSTER","ARRAY","ANALOGWAVEFORM","DIGITALWAVEFORM","isFloat","typeName","isSignedInteger","isUnsignedInteger","is64BitInteger","isInteger","isComplex","isNumeric","isTimeStamp","isAggregateType","validProperties","descriptor","propertyCount","keys","validatePrimitives","name","isValidArraySubtype","validateEnum","subtype","validateArray","validateType","rank","arrayFixedSize","size","reduce","prev","curr","validateCluster","fields","fieldTypes","fieldType","message","validateAnalogWaveform","type","wrapShortTypes","key","hasOwnProperty","map","unwrapShortType","encodeShortType","fieldsEqual","fields1","fields2","pv","cv","subtypesEqual","subtype1","subtype2","NIType","equals","ranksEqual","rank1","rank2","sizesEqual","sizes1","sizes2","parseDescriptor","descriptorValue","_descriptor","generateTypeCheker","typeChecker","defineProperty","typeDescriptorObject","isQuery","stringify","toShortJSON","makeArray","getName","getSubtype","_nisubtype","v","getRank","getSize","getFields","typeDescriptor","NITypes","NITypeNames"],"mappings":"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","file":"ni-data-types.min.js","sourcesContent":["//****************************************\r\n// NITimestamp data type\r\n// National Instruments Copyright 2016\r\n//****************************************\r\n\r\n(function () {\r\n    'use strict';\r\n\r\n    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\r\n    var epochDiffInSeconds = 2082844800; //the difference between JS epoch (1970) and LV Epoch (1904) in seconds.\r\n    var JSEpochInSeconds = 62135596800;\r\n\r\n    /* A NITimestamp can be created with no param, and with different types of parameters:\r\n         1. a string in the format '123:567890' where\r\n             the first part is an INT64 serialized to a decimal string, representing the nr. of seconds realtive to LV Epoch\r\n             the second part is a INT 64 reprezenting the fractional part\r\n         2. a javascript Date\r\n         3. a double number\r\n         4. a NITimestamp\r\n    */\r\n    var NITimestamp = function (value) {\r\n        var timeInMilliSeconds, timeInSeconds, remainder;\r\n        this.epochDiffInSeconds = epochDiffInSeconds; // TODO verify it and make it private\r\n\r\n        if (typeof value === 'string') {\r\n            var parts = value.split(':');\r\n            this.seconds = Math.floor(parseFloat(parts[0]));\r\n            var fractionalPart = parseFloat(parts[1]);\r\n\r\n            if (fractionalPart > 18446744073709550000) {\r\n                fractionalPart = 18446744073709550000;\r\n            }\r\n\r\n            this.fractions = Math.ceil(fractionalPart / 2048) / (MAX_SAFE_INTEGER + 1);\r\n        } else if (value instanceof Date) {\r\n            timeInMilliSeconds = value.getTime();\r\n            timeInSeconds = Math.floor(timeInMilliSeconds / 1000);\r\n            this.seconds = timeInSeconds + this.epochDiffInSeconds;\r\n            // JS % operator returns negative result if divisor is negative. This makes it positive.\r\n            remainder = ((timeInMilliSeconds % 1000) + 1000) % 1000;\r\n            this.fractions = remainder / 1000;\r\n        } else if (typeof value === 'number') {\r\n            timeInSeconds = Math.floor(value);\r\n            this.seconds = timeInSeconds;\r\n            this.fractions = value - timeInSeconds;\r\n        } else if (value instanceof NITimestamp) {\r\n            /*copy the timestamp*/\r\n            this.seconds = value.seconds;\r\n            this.fractions = value.fractions;\r\n        } else {\r\n            this.seconds = 0.0;\r\n            this.fractions = 0.0;\r\n        }\r\n    };\r\n\r\n    var proto = NITimestamp.prototype;\r\n\r\n    proto.toString = function () {\r\n        return '' + Math.floor(this.seconds) + ':' + Math.round(this.fractions * (MAX_SAFE_INTEGER + 1) * 2048);\r\n    };\r\n\r\n    proto.toJSON = function () {\r\n        return this.toString();\r\n    };\r\n\r\n    proto.toDate = function () {\r\n        return new Date((this.seconds - this.epochDiffInSeconds + this.fractions) * 1000);\r\n    };\r\n\r\n    proto.valueOf = function () {\r\n        return this.seconds + this.fractions;\r\n    };\r\n\r\n    /*calculates the seconds passed since the Gregorian epoch for this timestamp*/\r\n    proto.toAbsoluteTime = function () {\r\n        return this.seconds + this.fractions + JSEpochInSeconds - epochDiffInSeconds;\r\n    };\r\n\r\n    proto.compare = function (timestamp) {\r\n        if (this.seconds < timestamp.seconds) {\r\n            return -1;\r\n        } else if (this.seconds > timestamp.seconds) {\r\n            return 1;\r\n        } else {\r\n            if (this.fractions < timestamp.fractions) {\r\n                return -1;\r\n            } else if (this.fractions > timestamp.fractions) {\r\n                return 1;\r\n            } else {\r\n                return 0;\r\n            }\r\n        }\r\n    };\r\n\r\n    proto.add = function (dt) {\r\n        this.seconds += Math.floor(dt);\r\n        var fraction = dt - Math.floor(dt);\r\n        fraction += this.fractions;\r\n        if (fraction >= 1) {\r\n            fraction -= 1;\r\n            this.seconds += 1;\r\n        }\r\n\r\n        this.fractions = fraction;\r\n\r\n        return this; //enable chaining\r\n    };\r\n\r\n    window.NITimestamp = NITimestamp;\r\n}());\r\n","//****************************************\r\n// Analog Waveform data type\r\n// National Instruments Copyright 2016\r\n//****************************************\r\n\r\n(function () {\r\n    'use strict';\r\n    var NITimestamp = window.NITimestamp;\r\n\r\n    var NIAnalogWaveform = function (value) {\r\n        if (typeof value === 'string') {\r\n            try {\r\n                value = JSON.parse(value);\r\n            } catch (e) {\r\n                throw 'Can\\'t create an analog waveform from this value';\r\n            }\r\n            // falltrough, value is now an object parsed from the string,\r\n        }\r\n\r\n        if (value instanceof NIAnalogWaveform) {\r\n            this.t0 = new NITimestamp(value.t0 || '0:0');\r\n            this.channelName = value.channelName;\r\n            this.dt = value.dt;\r\n            this.Y = value.Y;\r\n        } else if (typeof value === 'object') {\r\n            this.t0 = new NITimestamp(value.t0 || '0:0');\r\n            this.channelName = value.channelName;\r\n            this.dt = value.dt || 0;\r\n            this.Y = value.Y;\r\n        } else if (value === undefined) {\r\n            this.dt = 0;\r\n            this.Y = [];\r\n            this.t0 = new NITimestamp();\r\n        } else {\r\n            throw 'Can\\'t create an analog waveform from this value';\r\n        }\r\n    };\r\n\r\n    var proto = NIAnalogWaveform.prototype;\r\n\r\n    proto.sampleCount = function () {\r\n        return this.Y.length;\r\n    };\r\n\r\n    // convert the waveform to an array of [timestamp, value] pairs\r\n    proto.toTimeAndValueArray = function () {\r\n        var res = [];\r\n        for (var i = 0, ts = this.t0; i < this.Y.length; i++, ts = ts.add(this.dt)) {\r\n            res.push([ts.toAbsoluteTime(), this.Y[i]]);\r\n        }\r\n\r\n        return res;\r\n    };\r\n\r\n    proto.appendArray = function (arr) {\r\n        if (Array.isArray(arr)) {\r\n            for (var i = 0; i < arr.length; i++) {\r\n                this.Y.push(arr[i]);\r\n            }\r\n        }\r\n    };\r\n\r\n    // append a waveform\r\n    proto.appendWaveform = function (waveform) {\r\n        if (waveform instanceof NIAnalogWaveform) {\r\n            if (waveform.dt !== this.dt) {\r\n                // we cannot merge two waveforms with different sampling rates. Discard the old one and use the new one.\r\n                this.t0 = waveform.t0;\r\n                this.dt = waveform.dt;\r\n                this.Y = waveform.Y.slice(0);\r\n            } else {\r\n                var expectedT0 = new window.NITimestamp(this.t0).add(this.dt * this.sampleCount());\r\n                if (waveform.t0.compare(expectedT0) === 0) {\r\n                    // append waveform data\r\n                    this.appendArray(waveform.Y);\r\n                } else {\r\n                    // we don't support gaps in waveforms yet\r\n                    this.t0 = waveform.t0;\r\n                    this.dt = waveform.dt;\r\n                    this.Y = waveform.Y.slice(0);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    proto.toJSON = function () {\r\n        var aw = {\r\n            t0: this.t0.toString(),\r\n            channelName: this.channelName,\r\n            dt: this.dt,\r\n            Y: this.Y\r\n        }\r\n\r\n        return aw;\r\n    };\r\n\r\n    window.NIAnalogWaveform = NIAnalogWaveform;\r\n}());\r\n","//****************************************\r\n// NIComplex data type\r\n// National Instruments Copyright 2016\r\n//****************************************\r\n\r\n(function () {\r\n    'use strict';\r\n\r\n    // Constructor Function\r\n    window.NIComplex = function (value, imag) {\r\n        if (typeof value === 'string') {\r\n            var complexNumber = this.parseFromString(value);\r\n            this.realPart = complexNumber[0];\r\n            this.imaginaryPart = complexNumber[1];\r\n        } else if (typeof value === 'number') {\r\n            this.realPart = value;\r\n            if (typeof imag === 'number') {\r\n                this.imaginaryPart = imag;\r\n            } else if (typeof imag === 'undefined') {\r\n                this.imaginaryPart = 0;\r\n            } else {\r\n                throw new Error('Can\\'t create complex number: invalid imaginary part');\r\n            }\r\n\r\n        } else {\r\n            throw new Error('Can\\'t create complex number');\r\n        }\r\n    };\r\n\r\n    // Static Private Variables\r\n    var spaceRemovalRegex = /\\s+/g;\r\n    var middleSignRegex = /([^eE][-+])|([eE][-+][iInN])/;\r\n    var testRealRegex = /^[-+]?([0-9]+|[0-9]+\\.|[0-9]*\\.[0-9]+)$/;\r\n    var testImagRegex = /^[-+]?([0-9]*|[0-9]+\\.|[0-9]*\\.[0-9]+)i$/;\r\n    var testRealScientificNotationRegex = /^[-+]?([0-9]+|[0-9]+\\.|[0-9]+\\.|[0-9]*\\.[0-9]+)[eE][-+]?[0-9]+$/;\r\n    var testImagScientificNotationRegex = /^[-+]?([0-9]+|[0-9]+\\.|[0-9]+\\.|[0-9]*\\.[0-9]+)[eE][-+]?[0-9]+i$/;\r\n    var checkRealInfinityRegex = /^[-+]?Infinity$/;\r\n    var checkImagInfinityRegex = /^[-+]?Infinityi$/;\r\n    var transformInfinityRegex = /[iI]nf(inity)?/g;\r\n    var checkOnlyI = /^[-+]?i$/;\r\n    var checkNaN = /^[-+]?NaNi?$/;\r\n    var fastPathComplexRegex = /^[-+]?([0-9]+|[0-9]+\\.[0-9]+)([eE][-+]?[0-9]+)?[-+]([0-9]+|[0-9]+\\.[0-9]+)([eE][-+]?[0-9]+)?i$/;\r\n    var realPartOnlyRegex = /^[+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?$/;\r\n    var imaginaryPartOnlyRegex = /^[+\\-]?((?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?i$/;\r\n    var realPartSIRegex = /^([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)(Y|Z|E|P|T|G|M|k|c|m|u|n|p|f|a|z|y){1}(?!i)$/;\r\n    var imaginaryPartSIRegex = /^([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)(Y|Z|E|P|T|G|M|k|c|m|u|n|p|f|a|z|y){1}i$/;\r\n    var scientificAndSINotationRegex = /^([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?E)(?!i)([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?E)i$/;\r\n    var scientificAndSINotationReversedRegex = /^([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?E)i([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?E)$/;\r\n\r\n    // Static Public Functions\r\n    // None\r\n\r\n    // Prototype creation\r\n    var proto = window.NIComplex.prototype;\r\n\r\n    // Static Private Functions\r\n    var getRealPart = function (value) {\r\n        var result;\r\n\r\n        if (value === '') {\r\n            return 0;\r\n        } else if (checkNaN.test(value)) {\r\n            return NaN;\r\n        }\r\n\r\n        if (value.search(/[eE]/) === -1) {\r\n            if (!(testRealRegex.test(value) || checkRealInfinityRegex.test(value))) {\r\n                throw new Error('Invalid real part format');\r\n            }\r\n\r\n            result = parseFloat(value);\r\n        } else {\r\n            if (!testRealScientificNotationRegex.test(value)) {\r\n                throw new Error('Invalid real part scientific notation');\r\n            }\r\n\r\n            result = parseFloat(value);\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    var getImaginaryPart = function (value) {\r\n        var result;\r\n\r\n        if (value === '') {\r\n            return 0;\r\n        } else if (checkNaN.test(value)) {\r\n            return NaN;\r\n        }\r\n\r\n        var valueWithoutI = value.slice(0, -1); //removes the i at the end\r\n\r\n        if (value.search(/[eE]/) === -1) {\r\n            if (!(testImagRegex.test(value) || checkImagInfinityRegex.test(value))) {\r\n                throw new Error('Invalid imaginary part format');\r\n            }\r\n\r\n            if (checkOnlyI.test(value)) {\r\n                return parseFloat(valueWithoutI + '1');\r\n            }\r\n\r\n            result = parseFloat(valueWithoutI);\r\n        } else {\r\n            if (!testImagScientificNotationRegex.test(value)) {\r\n                throw new Error('Invalid imaginary part scientific notation');\r\n            }\r\n\r\n            result = parseFloat(valueWithoutI);\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    var fastParseFromString = function (complexString) {\r\n        var middleSignIndex = complexString.search(middleSignRegex);\r\n        var real = parseFloat(complexString.substring(0, middleSignIndex + 1));\r\n        var imag = parseFloat(complexString.substring(middleSignIndex + 1, complexString.length - 1));\r\n\r\n        return [real, imag];\r\n    };\r\n\r\n    var thoroughParseFromString = function (complexString) {\r\n        var realSubString, imagSubString;\r\n\r\n        if (complexString === '' || typeof complexString === 'undefined' || complexString === null) {\r\n            throw new Error('Invalid number format');\r\n        }\r\n\r\n        complexString = complexString.replace(transformInfinityRegex, 'Infinity');\r\n\r\n        if (scientificAndSINotationRegex.test(complexString)) {\r\n            var parts = scientificAndSINotationRegex.exec(complexString),\r\n                realPartCoefficient = parts[1],\r\n                imaginaryPartCoefficient = parts[2];\r\n\r\n            return [scientificToDecimal(realPartCoefficient), scientificToDecimal(imaginaryPartCoefficient)];\r\n        }\r\n        else if (scientificAndSINotationReversedRegex.test(complexString)) {\r\n            var parts = scientificAndSINotationReversedRegex.exec(complexString),\r\n                realPartCoefficient = parts[2],\r\n                imaginaryPartCoefficient = parts[1];\r\n\r\n            return [scientificToDecimal(realPartCoefficient), scientificToDecimal(imaginaryPartCoefficient)];\r\n        }\r\n\r\n        var middleSignIndex = complexString.search(middleSignRegex);\r\n        var imagIndex = complexString.search(/i[-+]|i$/);\r\n\r\n        if (middleSignIndex < imagIndex) {\r\n            realSubString = complexString.substring(0, middleSignIndex + 1);\r\n            imagSubString = complexString.substring(middleSignIndex + 1);\r\n        } else {\r\n            imagSubString = complexString.substring(0, middleSignIndex + 1);\r\n            realSubString = complexString.substring(middleSignIndex + 1);\r\n        }\r\n\r\n        // Checks if real and/or imaginary parts have SI prefixes\r\n        var realPartSITest = realPartSIRegex.test(realSubString),\r\n            imaginaryPartSITest = imaginaryPartSIRegex.test(imagSubString),\r\n            realPart, imaginaryPart;\r\n\r\n        if (realPartSITest) {\r\n            realPart = scientificToDecimal(realSubString);\r\n            if (isNaN(realPart)) {\r\n                throw new Error('Invalid real part format');\r\n            }\r\n        }\r\n\r\n        if (imaginaryPartSITest) {\r\n            imaginaryPart = scientificToDecimal(imagSubString.slice(0, imagSubString.length - 1));\r\n            if (isNaN(imaginaryPart)) {\r\n                throw new Error('Invalid imaginary part format');\r\n            }\r\n        }\r\n\r\n        if (realPart !== undefined && imaginaryPart !== undefined) {\r\n            return [realPart, imaginaryPart];\r\n        }\r\n        else if (realPart !== undefined) {\r\n            return [realPart, getImaginaryPart(imagSubString)];\r\n        }\r\n        else if (imaginaryPart !== undefined) {\r\n            return [getRealPart(realSubString), imaginaryPart];\r\n        }\r\n\r\n        return [getRealPart(realSubString), getImaginaryPart(imagSubString)];\r\n    };\r\n\r\n    var scientificToDecimal = function (scientificValue) {\r\n        var prefixesToPowers = { 'Y': 24, 'Z': 21, 'E': 18, 'P': 15, 'T': 12, 'G': 9, 'M': 6, 'k': 3, 'c': -2, 'm': -3, 'u': -6, 'n': -9, 'p': -12, 'f': -15, 'a': -18, 'z': -21, 'y': -24 },\r\n            parts = realPartSIRegex.exec(scientificValue),\r\n            numericPart = parts[1],\r\n            prefix = parts[2],\r\n            number = parseFloat(numericPart) * (Math.pow(10, prefixesToPowers[prefix]));\r\n\r\n        return number;\r\n    };\r\n\r\n    // Public Prototype Methods\r\n    proto.parseFromString = function (complexString) {\r\n        complexString = complexString.replace(spaceRemovalRegex, '');\r\n\r\n        if (realPartOnlyRegex.test(complexString)) {\r\n            // if only real part has been passed in the string\r\n            return [parseFloat(complexString), 0];\r\n        } else if (imaginaryPartOnlyRegex.test(complexString)) {\r\n            // if only imaginary part has been passed in the string\r\n            var numericPartOfImaginary = complexString.slice(0, -1);\r\n            if (checkOnlyI.test(complexString)) {\r\n                numericPartOfImaginary += '1';\r\n            }\r\n            return [0, parseFloat(numericPartOfImaginary)];\r\n        } else if (fastPathComplexRegex.test(complexString)) {\r\n            return fastParseFromString(complexString);\r\n        } else {\r\n            return thoroughParseFromString(complexString);\r\n        }\r\n    };\r\n\r\n    proto.compare = function (complexNumb) {\r\n        var complexNumbMagnitute = Math.sqrt(Math.pow(complexNumb.realPart, 2) + Math.pow(complexNumb.imaginaryPart, 2));\r\n        var thisMagnitute = Math.sqrt(Math.pow(this.realPart, 2) + Math.pow(this.imaginaryPart, 2));\r\n\r\n        if (thisMagnitute > complexNumbMagnitute) {\r\n            return 1;\r\n        } else if (thisMagnitute < complexNumbMagnitute) {\r\n            return -1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    };\r\n\r\n    proto.toString = function () {\r\n        if (this.imaginaryPart >= 0) {\r\n            return this.realPart + ' + ' + this.imaginaryPart + 'i';\r\n        } else {\r\n            return this.realPart + ' - ' + Math.abs(this.imaginaryPart) + 'i';\r\n        }\r\n    };\r\n}());\r\n","//****************************************\r\n// NINumeric data type\r\n// National Instruments Copyright 2016\r\n//****************************************\r\n\r\n(function () {\r\n    'use strict';\r\n\r\n    // Constructor function\r\n    window.NINumericFormatters = function () {\r\n    };\r\n\r\n    // Static Private Variables\r\n    // None\r\n\r\n    // Static Public Functions\r\n    // None\r\n\r\n    // Prototype creation\r\n    var proto = window.NINumericFormatters.prototype;\r\n\r\n    // Static Private Functions\r\n    // Some browsers(PhantomJS, IE) dont support Math.log10(x)\r\n    var getLog10 = function (x) {\r\n        return Math.log(x) * Math.LOG10E;\r\n    };\r\n\r\n    var getExtension = function (exponent) {\r\n        var extensionTable = ['y', 'z', 'a', 'f', 'p', 'n', 'μ', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'];\r\n        var index = 8;\r\n\r\n        if (exponent >= 3) {\r\n            if (exponent >= 24) {\r\n                index = 16;\r\n            } else {\r\n                index = Math.floor(exponent / 3) + 8;\r\n            }\r\n        } else {\r\n            if (exponent <= -3) {\r\n                if (exponent <= -24) {\r\n                    index = 0;\r\n                } else {\r\n                    index = Math.round((exponent - 1) / 3) + 8;\r\n                }\r\n            }\r\n\r\n            if (exponent === -2 || exponent === -1) {\r\n                index = 7;\r\n            }\r\n        }\r\n\r\n        return {\r\n            conversion: Math.pow(10, (index - 8) * 3),\r\n            extension: extensionTable[index]\r\n        };\r\n    };\r\n\r\n    var removeLastZero = function (value) {\r\n        var numberStr = value;\r\n        if (typeof value !== 'string') {\r\n            numberStr = value.toString();\r\n        }\r\n\r\n        var exp = '';\r\n        var exponential = numberStr.indexOf('e') !== -1;\r\n        //split the number into mantissa and exponent\r\n        if (exponential) {\r\n            exp = numberStr.substring(numberStr.indexOf('e'), numberStr.length);\r\n            numberStr = numberStr.substring(0, numberStr.indexOf('e'));\r\n        }\r\n\r\n        var dotIndex = numberStr.indexOf('.');\r\n        //remove 0s\r\n        if (dotIndex !== -1) {\r\n            var lastZero = numberStr.lastIndexOf('0');\r\n\r\n            //remove 0s one by one\r\n            while (lastZero === numberStr.length - 1) {\r\n                numberStr = numberStr.slice(0, -1);\r\n                lastZero = numberStr.lastIndexOf('0');\r\n            }\r\n\r\n            //delete the dot if is last\r\n            if (dotIndex === numberStr.length - 1) {\r\n                numberStr = numberStr.slice(0, -1);\r\n            }\r\n        }\r\n\r\n        var result = '0';\r\n        if (numberStr !== '0' && numberStr !== '-0') {\r\n            result = numberStr;\r\n        }\r\n\r\n        //rebuild the number\r\n        return result + exp.toUpperCase();\r\n    };\r\n\r\n    // Public Prototype Methods\r\n    // toSiNotation(1.5e-8, 3) returns '15n'\r\n    // toSiNotation(1.5, 1) returns '1.5'\r\n    // toSiNotation(-1.5e12, 3) returns '-1.500T'\r\n    proto.toSiNotation = function (value, nrOfDecimals) {\r\n        var decimals = 0;\r\n        if (isFinite(nrOfDecimals) && nrOfDecimals !== null) {\r\n            if (nrOfDecimals > 20) {\r\n                decimals = 20;\r\n            } else {\r\n                if (nrOfDecimals < 0) {\r\n                    decimals = 0;\r\n                } else {\r\n                    decimals = nrOfDecimals;\r\n                }\r\n            }\r\n        }\r\n\r\n        var mantissa, extensionData;\r\n        if (value === 0) {\r\n            return '0';\r\n        } else {\r\n            if (value === null || value === undefined) {\r\n                return (value === null) ? 'null' : 'undefined';\r\n            }\r\n\r\n            if (!isFinite(value)) {\r\n                return isNaN(value) ? 'NaN' : value.toString();\r\n            }\r\n\r\n            var exponent = Math.floor(getLog10(Math.abs(value)));\r\n\r\n            extensionData = getExtension(exponent);\r\n            mantissa = value / extensionData.conversion;\r\n\r\n            if (exponent >= 45 || exponent <= -45) {\r\n                mantissa = mantissa.toExponential(decimals);\r\n            }\r\n        }\r\n\r\n        if (mantissa.toString().indexOf('e') === -1) {\r\n            mantissa = mantissa.toFixed(decimals);\r\n        }\r\n\r\n        var result = removeLastZero(mantissa),\r\n            extension = '';\r\n\r\n        if (result !== '0' && result !== '-0') {\r\n            extension = extensionData.extension;\r\n        }\r\n\r\n        return result + extension;\r\n    };\r\n\r\n    // toDecPrecision(1000, 2) returns '1E+3'\r\n    // toDecPrecision(-1.212E-21, 3) returns '-1.2E-21'\r\n    // toDecPrecision(1100.5, 4) returns '1101'\r\n    proto.toDecPrecisionNotation = function (value, nrOfDigits) {\r\n        if (value === null || value === undefined) {\r\n            return value === null ? 'null' : 'undefined';\r\n        }\r\n\r\n        if (!isFinite(value)) {\r\n            return isNaN(value) ? 'NaN' : value.toString();\r\n        }\r\n\r\n        var partialVal;\r\n        if (isFinite(nrOfDigits) && nrOfDigits !== null) {\r\n            var stringValue = Math.abs(value).toString();\r\n            var dotPosition = stringValue.indexOf('.');\r\n            var eNotation = (stringValue.indexOf('e') !== -1) || (stringValue.indexOf('E') !== -1);\r\n\r\n            if (dotPosition !== -1 && dotPosition < nrOfDigits && !eNotation) {\r\n                partialVal = value.toPrecision(nrOfDigits);\r\n            } else {\r\n                partialVal = (nrOfDigits < 1 || 21 < nrOfDigits || nrOfDigits > stringValue.length) ? value.toPrecision() : value.toPrecision(nrOfDigits);\r\n            }\r\n        } else {\r\n            partialVal = value.toPrecision();\r\n        }\r\n\r\n        return removeLastZero(partialVal);\r\n    };\r\n\r\n    // toDecFixedNotation(1000, 2) returns '1000.00'\r\n    // toDecFixedNotation(20.49, 0) returns '20'\r\n    // toDecFixedNotation(-1.2E-20, 20) returns '-0.00000000000000000001'\r\n    proto.toDecFixedNotation = function (value, nrOfecimals) {\r\n        if (value === null || value === undefined) {\r\n            return value === null ? 'null' : 'undefined';\r\n        }\r\n\r\n        if (!isFinite(value)) {\r\n            return isNaN(value) ? 'NaN' : value.toString();\r\n        }\r\n\r\n        // toFixed(decimals) on negative numbers represented in\r\n        // scientific notation(ex: -100E21) is returning a number(-1000000...) not a string('-1e+23')\r\n        var sign = '';\r\n        var number = value;\r\n        if (value < 0) {\r\n            sign = '-';\r\n            number = Math.abs(value);\r\n        }\r\n\r\n        var result = '0';\r\n        if (isFinite(nrOfecimals) && nrOfecimals !== null) {\r\n            if (nrOfecimals < 0 || 20 < nrOfecimals) {\r\n                result = number.toFixed();\r\n            } else {\r\n                result = number.toFixed(nrOfecimals);\r\n            }\r\n        } else {\r\n            result = number.toFixed();\r\n        }\r\n\r\n        return sign + result.toUpperCase();\r\n    };\r\n}());\r\n","\r\n(function () {\r\n\r\n    var TypeNames = Object.freeze({\r\n        VOID: 'Void',\r\n        BOOLEAN: 'Boolean',\r\n        UINT8: 'UInt8',\r\n        UINT16: 'UInt16',\r\n        UINT32: 'UInt32',\r\n        UINT64: 'UInt64',\r\n        INT8: 'Int8',\r\n        INT16: 'Int16',\r\n        INT32: 'Int32',\r\n        INT64: 'Int64',\r\n        SINGLE: 'Single',\r\n        DOUBLE: 'Double',\r\n        COMPLEXSINGLE: 'ComplexSingle',\r\n        COMPLEXDOUBLE: 'ComplexDouble',\r\n        STRING: 'String',\r\n        PATH: 'Path',\r\n        TIMESTAMP: 'Timestamp',\r\n        ENUM: 'Enum',\r\n        CLUSTER: 'Cluster',\r\n        ARRAY: 'Array',\r\n        ANALOGWAVEFORM: 'AnalogWaveform',\r\n        DIGITALWAVEFORM: 'DigitalWaveform'\r\n    });\r\n\r\n    // Numeric helper functions\r\n    var isFloat = function (typeName) {\r\n        return typeName === TypeNames.SINGLE || typeName === TypeNames.DOUBLE;\r\n    };\r\n\r\n    var isSignedInteger = function (typeName) {\r\n        switch (typeName) {\r\n            case TypeNames.INT8:\r\n            case TypeNames.INT16:\r\n            case TypeNames.INT32:\r\n            case TypeNames.INT64:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n\r\n    var isUnsignedInteger = function (typeName) {\r\n        switch (typeName) {\r\n            case TypeNames.UINT8:\r\n            case TypeNames.UINT16:\r\n            case TypeNames.UINT32:\r\n            case TypeNames.UINT64:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n\r\n    var is64BitInteger = function (typeName) {\r\n        return typeName === TypeNames.INT64 || typeName === TypeNames.UINT64;\r\n    };\r\n\r\n    var isInteger = function (typeName) {\r\n        return isSignedInteger(typeName) || isUnsignedInteger(typeName);\r\n    };\r\n\r\n    var isComplex = function (typeName) {\r\n        return typeName === TypeNames.COMPLEXSINGLE || typeName === TypeNames.COMPLEXDOUBLE;\r\n    };\r\n\r\n    var isNumeric = function (typeName) {\r\n        return isInteger(typeName) || isComplex(typeName) || isFloat(typeName);\r\n    };\r\n\r\n    var isTimeStamp = function (typeName) {\r\n        return typeName === TypeNames.TIMESTAMP;\r\n    }\r\n\r\n    var isAggregateType = function (typeName) {\r\n        if (isNumeric(typeName)) {\r\n            return false;\r\n        }\r\n\r\n        switch (typeName) {\r\n            case TypeNames.VOID:\r\n            case TypeNames.BOOLEAN:\r\n            case TypeNames.STRING:\r\n            case TypeNames.PATH:\r\n            case TypeNames.TIMESTAMP:\r\n            case TypeNames.DIGITALWAVEFORM:\r\n                return false;\r\n        }\r\n\r\n        return true;\r\n    };\r\n\r\n    // Validation methods\r\n    var throwIfInvalidProperties = function (descriptor, propertyCount, errorMessage) {\r\n        var descriptorKeys = Object.keys(descriptor);\r\n\r\n        if(descriptorKeys.length !== propertyCount) {\r\n            throw new Error(errorMessage);\r\n        }\r\n    };\r\n\r\n    var validProperties = function (descriptor, propertyCount) {\r\n        var descriptorKeys = Object.keys(descriptor);\r\n        return descriptorKeys.length !== propertyCount;\r\n    };\r\n\r\n    var validatePrimitives = function (descriptor) {\r\n        if (validProperties(descriptor, 1)) {\r\n            throw new Error(descriptor.name + ' must only have the property \"name\".');\r\n        }\r\n    };\r\n\r\n    var isValidArraySubtype = function (descriptor) {\r\n        return descriptor.name !== TypeNames.ARRAY;\r\n    };\r\n\r\n    var validateEnum = function (descriptor) {\r\n        var subtype = descriptor.subtype;\r\n\r\n        if(subtype === null || typeof subtype !== 'object') {\r\n            throw new Error('Enum subtype must be a valid descriptor.');\r\n        }\r\n\r\n        if(isUnsignedInteger(subtype.name) === false || is64BitInteger(subtype.name) === true) {\r\n            throw new Error('Enum unsupported subtype: ' + subtype.name);\r\n        }\r\n    };\r\n\r\n    var validateArray = function (descriptor) {\r\n\r\n        var subtype = descriptor.subtype;\r\n\r\n        if (isValidArraySubtype(subtype) === false) {\r\n            throw new Error('Invalid Array subtype: ' + subtype.name);\r\n        }\r\n\r\n        validateType(subtype);\r\n\r\n        var rank = descriptor.rank;\r\n\r\n        if (typeof rank !== 'number' || isNaN(rank) || rank <= 0) {\r\n            throw new Error('Array type property \"rank\" must be an integer greater than 0.');\r\n        }\r\n\r\n        var arrayFixedSize = descriptor.size;\r\n\r\n        if (arrayFixedSize !== undefined) {\r\n            if (Array.isArray(arrayFixedSize) === false) {\r\n                throw new Error('Array type property \"size\" must be an array of integers.');\r\n            }\r\n\r\n            var allElementsAreNumbersGreaterThanZero = arrayFixedSize.reduce(function (prev, curr){\r\n                return prev && typeof curr == 'number' && curr >= 0;\r\n            }, true);\r\n\r\n            if (allElementsAreNumbersGreaterThanZero === false) {\r\n                throw new Error('Array type property \"size\" must contain only natural numbers.');\r\n            }\r\n        }\r\n    };\r\n\r\n    var validateCluster = function (descriptor) {\r\n        var fields = descriptor.fields;\r\n        var fieldTypes = descriptor.subtype;\r\n\r\n        if (Array.isArray(fields) === false) {\r\n            throw new Error('Cluster type must have a \"fields\" property of type array.');\r\n        }\r\n\r\n        var allFieldsAreStrings = fields.reduce(function(prev, curr) {\r\n            return prev && typeof curr === 'string';\r\n        }, true);\r\n\r\n        if(allFieldsAreStrings === false) {\r\n            throw new Error('Cluster type property \"fields\", must be an array of strings.');\r\n        }\r\n\r\n        if (fieldTypes !== undefined) {\r\n            if (Array.isArray(fieldTypes) === false) {\r\n                throw new Error('Cluster type property \"subtype\" must be an array of types.');\r\n            }            \r\n\r\n            if (fields.length !== fieldTypes.length) {\r\n                throw new Error('Cluster properties \"fields\" and \"subtype\", must be arrays with the same length.');\r\n            }\r\n            \r\n            var i = 0;\r\n            try {\r\n                for (; i < fieldTypes.length; i++) {\r\n                    var fieldType = fieldTypes[i];\r\n                    validateType(fieldType);\r\n                }\r\n            } catch (e) {\r\n                throw new Error('Cluster property \"subtype\" contains an invalid type descriptor.\\n' + e.message);\r\n            }\r\n        }\r\n    };\r\n\r\n    var validateAnalogWaveform = function (descriptor) {\r\n        var subtype = descriptor.subtype;\r\n\r\n        if (subtype === undefined) {\r\n            throw new Error(TypeNames.ANALOGWAVEFORM + ' must have a property called \"subtype\".');\r\n        }\r\n\r\n        if (isNumeric(subtype.name) === false) {\r\n            throw new Error(TypeNames.ANALOGWAVEFORM + ' subtype only accepts numerics. ' + subtype.name + ' was found instead.');\r\n        }\r\n    };\r\n\r\n    var validateType = function (descriptor) {\r\n\r\n        if (descriptor !== null && typeof descriptor === 'object') {\r\n            var type = descriptor.name;\r\n\r\n            if (!isAggregateType(type)) {\r\n                validatePrimitives(descriptor);\r\n            } else {\r\n                switch (type) {\r\n                    case TypeNames.ENUM:\r\n                        validateEnum(descriptor);\r\n                        break;\r\n                    case TypeNames.ARRAY:\r\n                        validateArray(descriptor);\r\n                        break;\r\n                    case TypeNames.CLUSTER:\r\n                        validateCluster(descriptor);\r\n                        break;\r\n                    case TypeNames.ANALOGWAVEFORM:\r\n                        validateAnalogWaveform(descriptor);\r\n                        break;\r\n                    default:\r\n                        throw new Error('Unknown type: ' + type);\r\n                }\r\n            }\r\n\r\n        } else {\r\n            throw new Error('Descriptor should be a JSON encoded string or a valid format Object. Value found: ' + descriptor);\r\n        }\r\n        \r\n    };\r\n\r\n    // Short-type notation handling\r\n    var wrapShortTypes = function (descriptor) {\r\n        if (typeof descriptor === 'string') {\r\n            return {name: descriptor};\r\n        }\r\n\r\n        for(var key in descriptor) {\r\n            if (descriptor.hasOwnProperty(key)) {\r\n                var value = descriptor[key];\r\n                if (key === 'subtype') {\r\n                    if (Array.isArray(value)) {\r\n                        descriptor[key] = value.map(wrapShortTypes);\r\n                    } else {\r\n                        descriptor[key] = wrapShortTypes(value);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return descriptor;\r\n    };\r\n\r\n    var unwrapShortType = function (value) {\r\n        if (value !== null && typeof value === 'object' && !isAggregateType(value.name)) {\r\n            return value.name;\r\n        }\r\n\r\n        return value;\r\n    };\r\n\r\n    var encodeShortType = function (key, value) {\r\n        if (key === 'subtype' || key === '') { // Outermost key is always '' (empty string)\r\n            if (Array.isArray(value)) {\r\n                return value.map(unwrapShortType);\r\n            }\r\n\r\n            return unwrapShortType(value);\r\n        }\r\n        return value;\r\n    };\r\n\r\n    // Equals helper methods\r\n    var fieldsEqual = function (fields1, fields2) {\r\n        if (Array.isArray(fields1) && Array.isArray(fields2)) {\r\n\r\n            if (fields1.length !== fields2.length) {\r\n                return false;\r\n            }\r\n\r\n            return fields1.reduce(function (pv, cv, i) {\r\n                return pv && cv === fields2[i];\r\n            }, true);\r\n        }\r\n\r\n        return fields1 === fields2;\r\n    };\r\n\r\n    var subtypesEqual = function (subtype1, subtype2) {\r\n        if (subtype1 === undefined && subtype1 === subtype2) {\r\n            return true;\r\n        }\r\n\r\n        if (subtype1 instanceof NIType && subtype2 instanceof NIType) {\r\n            return subtype1.equals(subtype2);\r\n        }\r\n\r\n        if (Array.isArray(subtype1) && Array.isArray(subtype2)) {\r\n            var areEqual = subtype1.reduce(function (pv, cv, i) {\r\n                return pv && cv.equals(subtype2[i]);\r\n            }, true);\r\n\r\n            return areEqual;\r\n        }\r\n\r\n        return false;\r\n    };\r\n\r\n    var ranksEqual = function (rank1, rank2) {\r\n        if (rank1 === undefined && rank1 === rank2) {\r\n            return true;\r\n        }\r\n\r\n        return rank1 === rank2;\r\n    };\r\n\r\n    var sizesEqual = function (sizes1, sizes2) {\r\n        if (sizes1 === undefined && sizes1 === sizes2) {\r\n            return true;\r\n        }\r\n\r\n        if (sizes1.length !== sizes2.length) {\r\n            return false;\r\n        }\r\n\r\n        var areAllSizesEqual = sizes1.reduce(function (pv, cv, i) {\r\n            return pv && cv === sizes2[i];\r\n        }, true);\r\n\r\n        return areAllSizesEqual;\r\n    };\r\n\r\n    var parseDescriptor = function (descriptorValue) {\r\n        var descriptor;\r\n        if (typeof descriptorValue === 'string') {\r\n            if (!isAggregateType(descriptorValue)) {\r\n                descriptor = descriptorValue;\r\n            } else {\r\n                descriptor = JSON.parse(descriptorValue);\r\n            }\r\n        }\r\n\r\n        if (descriptorValue !== null && typeof descriptorValue === 'object') {\r\n            descriptor = descriptorValue;\r\n        }\r\n\r\n        descriptor = wrapShortTypes(descriptor);\r\n\r\n        return descriptor;\r\n    };\r\n\r\n    // Constructor\r\n    var NIType = function (descriptorValue) {\r\n        var descriptor = parseDescriptor(descriptorValue);\r\n        validateType(descriptor);\r\n        this._descriptor = descriptor;\r\n    };\r\n\r\n    var generateTypeCheker = function (typeName) {\r\n        var typeChecker = function () {\r\n            return this._descriptor.name === typeName;\r\n        };\r\n\r\n        try {\r\n            Object.defineProperty(typeChecker, 'name', {\r\n                value : 'is' + typeName\r\n            });\r\n        } catch (e) {\r\n            // Browser might not support this.\r\n        }\r\n\r\n        return typeChecker;\r\n    };\r\n\r\n    var addQueries = function (typeDescriptorObject) {\r\n        var proto = typeDescriptorObject.prototype;\r\n        for(var key in TypeNames) {\r\n            if (TypeNames.hasOwnProperty(key)) {\r\n                var typeName = TypeNames[key];\r\n                var isQuery = 'is' + typeName;\r\n\r\n                proto[isQuery] = generateTypeCheker(typeName);\r\n            }\r\n        }\r\n    };\r\n\r\n    // Public instance methods\r\n    var proto = NIType.prototype;\r\n\r\n    addQueries(NIType);\r\n\r\n    proto.toJSON = function () {\r\n        return JSON.stringify(this._descriptor);\r\n    };\r\n\r\n    proto.toShortJSON = function () {\r\n        return JSON.stringify(this._descriptor, encodeShortType);\r\n    };\r\n\r\n    proto.isNumeric = function () {\r\n        return isNumeric(this._descriptor.name);\r\n    };\r\n\r\n    proto.isFloat = function () {\r\n        return isFloat(this._descriptor.name);\r\n    };\r\n\r\n    proto.isSignedInteger = function () {\r\n        return isSignedInteger(this._descriptor.name);\r\n    };\r\n\r\n    proto.isUnsignedInteger = function () {\r\n        return isUnsignedInteger(this._descriptor.name);\r\n    };\r\n\r\n    proto.is64BitInteger = function () {\r\n        return is64BitInteger(this._descriptor.name);\r\n    };\r\n\r\n    proto.isInteger = function () {\r\n        return isInteger(this._descriptor.name);\r\n    };\r\n\r\n    proto.isComplex = function () {\r\n        return isComplex(this._descriptor.name);\r\n    };\r\n\r\n    proto.isTimeStamp = function () {\r\n        return isTimeStamp(this._descriptor.name);\r\n    }\r\n\r\n    proto.isAggregateType = function() {\r\n        return isAggregateType(this._descriptor.name);\r\n    }\r\n\r\n    proto.makeArray = function (rank, size) {\r\n        if (this.isArray()) {\r\n            throw new Error('Not possible to create an array from an array.');\r\n        } else {\r\n            if (rank === undefined) {\r\n                rank = 1;\r\n            }\r\n\r\n            var subtype = JSON.parse(this.toShortJSON());\r\n\r\n            return new NIType({name: TypeNames.ARRAY, rank: rank, subtype: subtype, size: size});\r\n        }\r\n    };\r\n\r\n    proto.getName = function () {\r\n        return this._descriptor.name;\r\n    };\r\n\r\n    proto.getSubtype = function () {\r\n        if (this._nisubtype !== undefined) {\r\n            return this._nisubtype;\r\n        }\r\n\r\n        var subtype = this._descriptor.subtype;\r\n\r\n        if (Array.isArray(subtype)) {\r\n            this._nisubtype = subtype.map(function (v) {\r\n                return new NIType(v);\r\n            });\r\n\r\n        } else if (typeof subtype === 'object' && subtype !== null) {\r\n            this._nisubtype = new NIType(subtype);\r\n        }\r\n\r\n        return this._nisubtype;\r\n    };\r\n\r\n    proto.getRank = function () {\r\n        return this._descriptor.rank;\r\n    };\r\n\r\n    proto.getSize = function () {\r\n        return this._descriptor.size;\r\n    };\r\n\r\n    proto.getFields = function () {\r\n        return this._descriptor.fields;\r\n    };\r\n\r\n    proto.equals = function (typeDescriptor) {\r\n        if (typeDescriptor instanceof NIType) {\r\n            if (typeDescriptor.getName() !== this.getName()) {\r\n                return false;\r\n            }\r\n\r\n            if (!fieldsEqual(typeDescriptor.getFields(), this.getFields())) {\r\n                return false;\r\n            }\r\n\r\n            if (!subtypesEqual(typeDescriptor.getSubtype(), this.getSubtype())) {\r\n                return false;\r\n            }\r\n\r\n            if (!ranksEqual(typeDescriptor.getRank(), this.getRank())) {\r\n                return false;\r\n            }\r\n\r\n            if (!sizesEqual(typeDescriptor.getSize(), this.getSize())) {\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    };\r\n\r\n    // Exports\r\n    window.NITypes = Object.freeze({\r\n        VOID: new NIType('\"Void\"'),\r\n        BOOLEAN: new NIType('\"Boolean\"'),\r\n        UINT8: new NIType('\"UInt8\"'),\r\n        UINT16: new NIType('\"UInt16\"'),\r\n        UINT32: new NIType('\"UInt32\"'),\r\n        UINT64: new NIType('\"UInt64\"'),\r\n        INT8: new NIType('\"Int8\"'),\r\n        INT16: new NIType('\"Int16\"'),\r\n        INT32: new NIType('\"Int32\"'),\r\n        INT64: new NIType('\"Int64\"'),\r\n        SINGLE: new NIType('\"Single\"'),\r\n        DOUBLE: new NIType('\"Double\"'),\r\n        COMPLEXSINGLE: new NIType('\"ComplexSingle\"'),\r\n        COMPLEXDOUBLE: new NIType('\"ComplexDouble\"'),\r\n        STRING: new NIType('\"String\"'),\r\n        PATH: new NIType('\"Path\"'),\r\n        TIMESTAMP: new NIType('\"Timestamp\"'),\r\n        DIGITALWAVEFORM: new NIType('\"DigitalWaveform\"')\r\n    });\r\n\r\n    window.NIType = NIType;\r\n    window.NITypeNames = TypeNames;\r\n}());\r\n"]}