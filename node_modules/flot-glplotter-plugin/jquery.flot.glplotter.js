(function(global, $) {
    function GlPlotter() {
        this.pluginName = 'glplotter';
        this.pluginVersion = '0.2';

        /**
         * Initialize the flot-gl-plotter-plugin
         * Adds the processOptions hook
         */
        this.init = function(plot) {
            var defaultPlotOffset = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            };

            var container, canvas, width, height,
                renderer, pixelRatio, mustClear = false;

            if (isTHREEAvailable()) {
                plot.hooks.processOptions.push(processOptions);
            }

            /**
             * Checks if Threejs is available
             */
            function isTHREEAvailable() {
                return typeof THREE !== 'undefined';
            };

            /**
             * Initialize the webgl drawing layer, renderer, camera and scene
             * Adds the hooks needed for drawing
             */
            function processOptions(plot, options) {
                var mainScene, camera, cameraFocus;
                container = plot.getPlaceholder()[0];

                if (isGlRequested()) {
                    if (setupWebGl()) {
                        resize(plot, width, height);
                        plot.hooks.drawSeries.push(drawSeries);
                        plot.hooks.draw.push(render);
                        plot.hooks.resize.push(resize);
                        plot.hooks.drawBackground.push(clear);
                        plot.hooks.shutdown.push(shutdown);
                    }
                }
            };

            /**
             * Initialize the webgl drawing layer, renderer, camera and the scene
             */
            function setupWebGl() {
                if (!canvas) {
                    canvas = getGlSurface("flot-gl", container);
                }

                if(!renderer) {
                    try {
                        renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: false, alpha: true, preserveDrawingBuffer: false });
                        mainScene = new THREE.Scene();
                        camera = new THREE.OrthographicCamera(width / 2, -width / 2, -height / 2, height / 2, 0.1, 1000);
                        cameraFocus = new THREE.Vector3(width / 2, height / 2, 1000);
                    } catch (e) {
                        console.warn("Cannot create WebGlRenderer: " + e);
                        return false;
                    }
                    var devicePixelRatio = window.devicePixelRatio || 1;
                    var backingStoreRatio =
                            renderer.webkitBackingStorePixelRatio ||
                            renderer.mozBackingStorePixelRatio ||
                            renderer.msBackingStorePixelRatio ||
                            renderer.oBackingStorePixelRatio ||
                            renderer.backingStorePixelRatio || 1;

                    pixelRatio = devicePixelRatio / backingStoreRatio;
                } else {
                    mainScene = renderer.userData.mainScene;
                    camera = renderer.userData.camera;
                    cameraFocus = camera.userData.cameraFocus;
                }

                // Setup the THREE.OrthographicCamera
                camera.aspect = width / height;
                camera.position.set(width / 2, height / 2, 0);
                camera.lookAt(cameraFocus);
                camera.updateMatrixWorld();
                camera.updateProjectionMatrix();

                // Setup the THREE.WebGLRenderer
                renderer.setPixelRatio(pixelRatio);
                renderer.setSize(width, height, true);
                renderer.autoClear = true;
                renderer.userData = {};

                // Save settings for future reuse.
                camera.userData.cameraFocus = cameraFocus;
                renderer.userData.camera = camera;
                renderer.userData.mainScene = mainScene;
                renderer.userData.plotOffset = defaultPlotOffset;

                return true;
            }

            /**
             * Return the webgl drawing layer, create one if needed
             */
            function getGlSurface(cls, container) {
                var element = container.getElementsByClassName(cls)[0];
                var flotBaseElement = container.getElementsByClassName("flot-base")[0];

                if (!element) {
                    element = document.createElement('canvas');
                    element.className = cls;
                    element.style.direction = 'ltr';
                    element.style.position = 'absolute';
                    element.style.left = '0px';
                    element.style.top = '0px';

                    container.insertBefore(element, flotBaseElement.nextSibling);
                }

                var box = container.getBoundingClientRect();

                // Size the canvas to match the internal dimensions of its container
                width = box.width;
                height = box.height;

                return element;
            };

            /**
             * Render the visible plotObjects contained inside the scene
             * All invisible objects will be removed from scene before rendering
             */
            function render() {
                var camera = renderer.userData.camera,
                    mainScene = renderer.userData.mainScene,
                    cameraFocus = camera.userData.cameraFocus,
                    plotOffset = renderer.userData.plotOffset || defaultPlotOffset;

                // Remove invisible objects from the scene
                mainScene.children.forEach(function(plotObject) {
                    if (!plotObject.visible) {
                        mainScene.remove(plotObject);
                    }
                });

                cameraFocus.x = width / 2;
                cameraFocus.y = height / 2;
                cameraFocus.z = 1000;
                renderer.clear();
                renderer.setSize(width, height, false);
                renderer.setViewport(0, 0, width, height);

                camera.position.set(width / 2, height / 2, 0);
                camera.lookAt(cameraFocus);
                camera.updateProjectionMatrix();
                camera.updateMatrixWorld();

                renderer.setScissor(
                    plotOffset.left,
                    plotOffset.top,
                    width - plotOffset.right - plotOffset.left,
                    height - plotOffset.bottom - plotOffset.top
                );

                renderer.render(mainScene, camera);
                renderer.clearDepth();
            };

            function resize(plot, newWidth, newHeight) {
                var userData = renderer.userData,
                    minSize = 10,
                    shouldresize = false,
                    element = canvas;

                    newWidth = newWidth < minSize ? minSize : newWidth;
                    newHeight = newHeight < minSize ? minSize : newHeight;

                    if (width !== newWidth) {
                        element.width = newWidth * pixelRatio;
                        element.style.width = newWidth + 'px';
                        width = newWidth;
                        shouldresize = true;
                    }

                    if (height !== newHeight) {
                        element.height = newHeight * pixelRatio;
                        element.style.height = newHeight + 'px';
                        height = newHeight;
                        shouldresize = true;
                    }

                    if (renderer && shouldresize) {
                        var mainscene = renderer.userData.mainScene,
                            camera = renderer.userData.camera;

                        renderer.setClearColor(0xff0000, 0);
                        renderer.setSize(width, height, false);
                        renderer.setPixelRatio(pixelRatio);

                        if (camera) {
                            camera.aspect = width/height;
                            camera.userData.cameraFocus.x = width / 2;
                            camera.userData.cameraFocus.y = height / 2;
                            camera.userData.cameraFocus.z = 1000;

                            camera.position.set(width / 2, height / 2, 0);
                            camera.lookAt(camera.userData.cameraFocus);
                            camera.updateProjectionMatrix();
                        }

                        renderer.clear();
                    }
            };

            /**
             * Clears the renderer and sets the visibility of the objects to false
             */
            function clear() {
                if (renderer && mustClear) {
                    mustClear = false;
                    // Make objects invisible
                    var mainscene = renderer.userData.mainScene;
                    mainscene.children.forEach(function(plotObject) {
                        plotObject.visible = false;
                    });

                    // Clear the renderer
                    renderer.setClearColor(0x0f0f0f, 0);
                    renderer.setScissorTest(false);
                    renderer.clear();

                    renderer.setClearColor(0xff0000, 0);
                    renderer.setScissorTest(true);
                    renderer.clear();
                }
            };

            /**
             * Remove objects from scene and free memory
             */
            function shutdown() {
                var mainscene = renderer.userData.mainScene;
                while(mainscene.children.length > 0) {
                    mainscene.children[0].material.dispose(true);
                    mainscene.children[0].geometry.dispose(true);
                    mainscene.remove(mainscene.children[0]);
                }

                mainscene = null;
                renderer.userData = null;
                renderer.dispose(true);
                canvas.remove();
            };

            /**
             * Draw using the Three.js library for rendering
             * Each plot is trasformed to a plotObject (THREE.Object3D)
             * For every point, a vertex is added to the plotObject's geometry
             *
             * Currently, the only type of drawing is points which uses the THREE.Points for creating the plotObject.
             * Not Implemented: support for Lines, Area, Bars (Ex: drawSeriesLines -> THREE.Line() as a plotObject)
             */
            function drawSeries(plot, ctx, series, index, getColorOrGradient) {
                var plotOffset = plot.getPlotOffset(),
                    plotWidth, plotHeight;
                if (mustDrawSeriesWithGl(series)) {
                    mustClear = true;
                    series.points.show = false;
                    series.points.glshow = true;
                    renderer.userData.plotOffset = plotOffset;

                    var datapoints = {
                        points: series.datapoints.points,
                        pointsize: series.datapoints.pointsize
                    };

                    if (series.decimatePoints) {
                        //after adjusting the axis, plot width and height will be modified
                        plotWidth = width - plotOffset.left - plotOffset.right;
                        plotHeight = height - plotOffset.bottom - plotOffset.top;
                        datapoints.points = series.decimatePoints(
                            series,
                            series.xaxis.min,
                            series.xaxis.max,
                            plotWidth,
                            series.yaxis.min,
                            series.yaxis.max,
                            plotHeight
                        );
                    }

                    drawSeriesPoints(
                        renderer,
                        pointsToVertices(datapoints, index, series, plotOffset),
                        index,
                        series,
                        getColorOrGradient
                    );
                }
            };

            /**
             * Checks the settings and url flags
             */
            function mustDrawSeriesWithGl(series) {
                return series.points.glshow || (series.points.show && isGlRequested());
            };

            /**
             * Checks for the gl=true flag inside the url params
             */
            function isGlRequested() {
                var url = window.location.href,
                    params = url.split('?')[1];

                if (params && params.includes('gl=true')) {
                    return true;
                }
                return false;
            };

            /**
             * Transform the list of 2D points(x,y) to 3D points(x,y,z) TypedArray
             * The z coord is the same for all
             * @param {*} index - plot index, used to set the plotObject's position on z direction
             */
            function pointsToVertices(datapoints, index, series, offset) {
                var points = datapoints.points,
                    ps = datapoints.pointsize,
                    i, j = 0, z = 1000 - index / 10,
                    vertices = new Float32Array(points.length / ps * 3);
                for (i = 0; i < points.length; i += ps) {
                    if (points[i] == null) continue;

                    // set x,y,z coords of point
                    vertices[j] = series.xaxis.p2c(points[i]) + offset.left;
                    vertices[j + 1] = series.yaxis.p2c(points[i + 1]) + offset.top;
                    vertices[j + 2] = z;
                    j += 3;
                }

                return vertices;
            }

            /**
             * Uses the THREE.Points as a plotObject for drawing the plot using points
             * Adds an plotObject to the scene / Update an plotObject from the scene
             * Makes the plotObject visible before rendering
             */
            function drawSeriesPoints(renderer, vertices, index, series, getColorOrGradient) {
                var mainscene = renderer.userData.mainScene,
                    plotObject = mainscene.getObjectByName('Plot' + index),
                    vs = 3;

                if (plotObject) {
                    updateGeometry(plotObject, vertices, vs);
                    plotObject.visible = true;
                } else {
                    plotObject = new THREE.Points(
                            generateGeometry(vertices, vs),
                            generateMaterial(series, getColorOrGradient)
                        );
                    plotObject.name = 'Plot' + index;
                    mainscene.add(plotObject);
                }
            };

            /**
             * Creates a BufferGeometry from a TypedArray of vertices
             */
            function generateGeometry(vertices, vertexSize) {
                var geometry = new THREE.BufferGeometry();
                geometry.addAttribute('position', new THREE.Float32BufferAttribute(vertices, vertexSize));
                geometry.attributes.position.dynamic = true;
                geometry.attributes.position.needsUpdate = true;
                return geometry;
            };

            /**
             * Update plotObject's geometry
             * If the plotObject geometry is big enough, update position and draw range,
             * else dispose the plotObject's geometry and generate a new one to fit the data
             */
            function updateGeometry(plotObject, vertices, vertexSize) {
                var geometry = plotObject.geometry;
                if (geometry.attributes.position.count >= vertices.length / vertexSize) {
                    geometry.attributes.position.setArray(vertices);
                    geometry.setDrawRange(0, vertices.length / vertexSize);
                    geometry.attributes.position.needsUpdate = true;
                } else {
                    geometry.dispose(true);
                    plotObject.geometry = generateGeometry(vertices, vertexSize);
                }
            };

            /**
             * Generate a material for points
             */
            function generateMaterial(series, getColorOrGradient) {
                return new THREE.PointsMaterial({
                        size: series.points.radius * 4,
                        sizeAttenuation: false,
                        map: generateTexture(series, getColorOrGradient),
                        transparent: true,
                        fog: false,
                        alphaTest: 0.1
                    });
            };

            /**
             * Create a texture for points
             */
            function generateTexture(series, getColorOrGradient){
                var filloptions = getFillStyle(series.points, series.color, null, null, getColorOrGradient) || series.color;
                return createTexture(series.points.symbol, series.points.lineWidth, series.color, filloptions, plot.drawSymbol)
            };

            function getFillStyle(filloptions, seriesColor, bottom, top, getColorOrGradient) {
                var fill = filloptions.fill;
                if (!fill) {
                    return null;
                }

                if (filloptions.fillColor) {
                    return getColorOrGradient(filloptions.fillColor, bottom, top, seriesColor);
                }

                var c = $.color.parse(seriesColor);
                c.a = typeof fill === "number" ? fill : 0.4;
                c.normalize();
                return c.toString();
            };

            /**
             * Use flot drawSymbol function(2D canvas) to achieve the same visual style of points
             * by drawing a single point to a temporary 2D canvas and then transforming the canvas to a texture
             */
            function createTexture(symbol, lineWidth, color, filloptions, drawSymbol) {
                var textureCanvas, context, texture;
                var size = 128;
                var halfSize = size / 2;
                textureCanvas = document.createElement('canvas');
                textureCanvas.width = size;
                textureCanvas.height = size;
                context = textureCanvas.getContext('2d');
                context.clearRect(0, 0, size, size);
                context.globalAlpha = 1;
                context.strokeStyle = color;
                context.lineWidth = (lineWidth || 1) * size / 10;

                if (symbol === "circle") {
                    context.arc(halfSize, halfSize, size / 4, 0, 2 * Math.PI);
                } else if (typeof symbol === 'string' && drawSymbol && drawSymbol[symbol]) {
                    drawSymbol[symbol](context, halfSize, halfSize, size / 4, false);
                } else if (typeof drawSymbol === 'function') {
                    drawSymbol(context, halfSize, halfSize, size / 4, false);
                }

                context.fillStyle = filloptions;
                context.fill();
                context.stroke();

                texture = new THREE.CanvasTexture(textureCanvas);
                texture.minFilter = THREE.LinearFilter;
                texture.needsUpdate = true;

                return texture;
            };
        };
    };

    var glplotter = new GlPlotter();
    $.plot.plugins.push({
        init: glplotter.init,
        name: glplotter.pluginName,
        version: glplotter.pluginVersion
    });
    global.GlPlotter = GlPlotter;
})(this, jQuery);
